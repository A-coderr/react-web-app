{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hookDecorator = exports.objectHooks = exports.functionHooks = exports.getOriginal = void 0;\nconst compose_js_1 = require(\"./compose.js\");\nconst base_js_1 = require(\"./base.js\");\nconst utils_js_1 = require(\"./utils.js\");\nfunction getOriginal(fn) {\n  return typeof fn.original === 'function' ? getOriginal(fn.original) : fn;\n}\nexports.getOriginal = getOriginal;\nfunction functionHooks(fn, managerOrMiddleware) {\n  if (typeof fn !== 'function') {\n    throw new Error('Can not apply hooks to non-function');\n  }\n  const manager = (0, base_js_1.convertOptions)(managerOrMiddleware);\n  const wrapper = function (...args) {\n    const {\n      Context,\n      original\n    } = wrapper;\n    // If we got passed an existing HookContext instance, we want to return it as well\n    const returnContext = args[args.length - 1] instanceof Context;\n    // Use existing context or default\n    const base = returnContext ? args.pop() : new Context();\n    // Initialize the context\n    const context = manager.initializeContext(this, args, base);\n    // Assemble the hook chain\n    const hookChain = [\n    // Return `ctx.result` or the context\n    (ctx, next) => next().then(() => returnContext ? ctx : ctx.result)];\n    // Create the hook chain by calling the `collectMiddleware function\n    const mw = manager.collectMiddleware(this, args);\n    if (mw) {\n      Array.prototype.push.apply(hookChain, mw);\n    }\n    // Runs the actual original method if `ctx.result` is not already set\n    hookChain.push((ctx, next) => {\n      if (!Object.prototype.hasOwnProperty.call(context, 'result')) {\n        return Promise.resolve(original.apply(this, ctx.arguments)).then(result => {\n          ctx.result = result;\n          return next();\n        });\n      }\n      return next();\n    });\n    return (0, compose_js_1.compose)(hookChain).call(this, context);\n  };\n  (0, utils_js_1.copyFnProperties)(wrapper, fn);\n  (0, utils_js_1.copyProperties)(wrapper, fn);\n  (0, base_js_1.setManager)(wrapper, manager);\n  return Object.assign(wrapper, {\n    original: getOriginal(fn),\n    Context: manager.getContextClass(),\n    createContext: (data = {}) => {\n      return new wrapper.Context(data);\n    }\n  });\n}\nexports.functionHooks = functionHooks;\nfunction objectHooks(obj, hooks) {\n  if (Array.isArray(hooks)) {\n    return (0, base_js_1.setMiddleware)(obj, hooks);\n  }\n  for (const method of Object.keys(hooks)) {\n    const target = typeof obj[method] === 'function' ? obj : obj.prototype;\n    const fn = target && target[method];\n    if (typeof fn !== 'function') {\n      throw new Error(`Can not apply hooks. '${method}' is not a function`);\n    }\n    const manager = (0, base_js_1.convertOptions)(hooks[method]);\n    target[method] = functionHooks(fn, manager.props({\n      method\n    }));\n  }\n  return obj;\n}\nexports.objectHooks = objectHooks;\nconst hookDecorator = managerOrMiddleware => {\n  const wrapper = (_target, method, descriptor) => {\n    const manager = (0, base_js_1.convertOptions)(managerOrMiddleware);\n    if (!descriptor) {\n      (0, base_js_1.setManager)(_target.prototype, manager);\n      return _target;\n    }\n    const fn = descriptor.value;\n    if (typeof fn !== 'function') {\n      throw new Error(`Can not apply hooks. '${method}' is not a function`);\n    }\n    descriptor.value = functionHooks(fn, manager.props({\n      method\n    }));\n    return descriptor;\n  };\n  return wrapper;\n};\nexports.hookDecorator = hookDecorator;","map":{"version":3,"names":["Object","defineProperty","exports","value","hookDecorator","objectHooks","functionHooks","getOriginal","compose_js_1","require","base_js_1","utils_js_1","fn","original","managerOrMiddleware","Error","manager","convertOptions","wrapper","args","Context","returnContext","length","base","pop","context","initializeContext","hookChain","ctx","next","then","result","mw","collectMiddleware","Array","prototype","push","apply","hasOwnProperty","call","Promise","resolve","arguments","compose","copyFnProperties","copyProperties","setManager","assign","getContextClass","createContext","data","obj","hooks","isArray","setMiddleware","method","keys","target","props","_target","descriptor"],"sources":["C:/Users/VARLab ROG 1/Documents/workspace/web/react-frontend/node_modules/@feathersjs/hooks/script/hooks.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hookDecorator = exports.objectHooks = exports.functionHooks = exports.getOriginal = void 0;\nconst compose_js_1 = require(\"./compose.js\");\nconst base_js_1 = require(\"./base.js\");\nconst utils_js_1 = require(\"./utils.js\");\nfunction getOriginal(fn) {\n    return typeof fn.original === 'function' ? getOriginal(fn.original) : fn;\n}\nexports.getOriginal = getOriginal;\nfunction functionHooks(fn, managerOrMiddleware) {\n    if (typeof fn !== 'function') {\n        throw new Error('Can not apply hooks to non-function');\n    }\n    const manager = (0, base_js_1.convertOptions)(managerOrMiddleware);\n    const wrapper = function (...args) {\n        const { Context, original } = wrapper;\n        // If we got passed an existing HookContext instance, we want to return it as well\n        const returnContext = args[args.length - 1] instanceof Context;\n        // Use existing context or default\n        const base = returnContext ? args.pop() : new Context();\n        // Initialize the context\n        const context = manager.initializeContext(this, args, base);\n        // Assemble the hook chain\n        const hookChain = [\n            // Return `ctx.result` or the context\n            (ctx, next) => next().then(() => returnContext ? ctx : ctx.result),\n        ];\n        // Create the hook chain by calling the `collectMiddleware function\n        const mw = manager.collectMiddleware(this, args);\n        if (mw) {\n            Array.prototype.push.apply(hookChain, mw);\n        }\n        // Runs the actual original method if `ctx.result` is not already set\n        hookChain.push((ctx, next) => {\n            if (!Object.prototype.hasOwnProperty.call(context, 'result')) {\n                return Promise.resolve(original.apply(this, ctx.arguments)).then((result) => {\n                    ctx.result = result;\n                    return next();\n                });\n            }\n            return next();\n        });\n        return (0, compose_js_1.compose)(hookChain).call(this, context);\n    };\n    (0, utils_js_1.copyFnProperties)(wrapper, fn);\n    (0, utils_js_1.copyProperties)(wrapper, fn);\n    (0, base_js_1.setManager)(wrapper, manager);\n    return Object.assign(wrapper, {\n        original: getOriginal(fn),\n        Context: manager.getContextClass(),\n        createContext: (data = {}) => {\n            return new wrapper.Context(data);\n        },\n    });\n}\nexports.functionHooks = functionHooks;\nfunction objectHooks(obj, hooks) {\n    if (Array.isArray(hooks)) {\n        return (0, base_js_1.setMiddleware)(obj, hooks);\n    }\n    for (const method of Object.keys(hooks)) {\n        const target = typeof obj[method] === 'function' ? obj : obj.prototype;\n        const fn = target && target[method];\n        if (typeof fn !== 'function') {\n            throw new Error(`Can not apply hooks. '${method}' is not a function`);\n        }\n        const manager = (0, base_js_1.convertOptions)(hooks[method]);\n        target[method] = functionHooks(fn, manager.props({ method }));\n    }\n    return obj;\n}\nexports.objectHooks = objectHooks;\nconst hookDecorator = (managerOrMiddleware) => {\n    const wrapper = (_target, method, descriptor) => {\n        const manager = (0, base_js_1.convertOptions)(managerOrMiddleware);\n        if (!descriptor) {\n            (0, base_js_1.setManager)(_target.prototype, manager);\n            return _target;\n        }\n        const fn = descriptor.value;\n        if (typeof fn !== 'function') {\n            throw new Error(`Can not apply hooks. '${method}' is not a function`);\n        }\n        descriptor.value = functionHooks(fn, manager.props({ method }));\n        return descriptor;\n    };\n    return wrapper;\n};\nexports.hookDecorator = hookDecorator;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}