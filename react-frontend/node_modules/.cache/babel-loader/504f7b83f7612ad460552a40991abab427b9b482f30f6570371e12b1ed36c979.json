{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CombinedChannel = exports.Channel = exports.channels = exports.keys = void 0;\nconst feathers_1 = require(\"@feathersjs/feathers\");\nconst commons_1 = require(\"@feathersjs/commons\");\nconst lodash_1 = require(\"lodash\");\nconst base_1 = require(\"./channel/base\");\nObject.defineProperty(exports, \"Channel\", {\n  enumerable: true,\n  get: function () {\n    return base_1.Channel;\n  }\n});\nconst combined_1 = require(\"./channel/combined\");\nObject.defineProperty(exports, \"CombinedChannel\", {\n  enumerable: true,\n  get: function () {\n    return combined_1.CombinedChannel;\n  }\n});\nconst mixins_1 = require(\"./mixins\");\nObject.defineProperty(exports, \"keys\", {\n  enumerable: true,\n  get: function () {\n    return mixins_1.keys;\n  }\n});\nconst debug = (0, commons_1.createDebug)('@feathersjs/transport-commons/channels');\nconst {\n  CHANNELS\n} = mixins_1.keys;\nfunction channels() {\n  return app => {\n    if (typeof app.channel === 'function' && typeof app.publish === 'function') {\n      return;\n    }\n    Object.assign(app, (0, mixins_1.channelMixin)(), (0, mixins_1.publishMixin)());\n    Object.defineProperty(app, 'channels', {\n      get() {\n        return Object.keys(this[CHANNELS]);\n      }\n    });\n    app.mixins.push((service, path) => {\n      const {\n        serviceEvents\n      } = (0, feathers_1.getServiceOptions)(service);\n      if (typeof service.publish === 'function') {\n        return;\n      }\n      Object.assign(service, (0, mixins_1.publishMixin)());\n      serviceEvents.forEach(event => {\n        service.on(event, function (data, hook) {\n          if (!hook) {\n            // Fake hook for custom events\n            hook = {\n              path,\n              service,\n              app,\n              result: data\n            };\n          }\n          debug('Publishing event', event, hook.path);\n          const logError = error => debug(`Error in '${hook.path} ${event}' publisher`, error);\n          const servicePublishers = service[mixins_1.keys.PUBLISHERS];\n          const appPublishers = app[mixins_1.keys.PUBLISHERS];\n          // This will return the first publisher list that is not empty\n          // In the following precedence\n          const publisher =\n          // 1. Service publisher for a specific event\n          servicePublishers[event] ||\n          // 2. Service publisher for all events\n          servicePublishers[mixins_1.keys.ALL_EVENTS] ||\n          // 3. App publisher for a specific event\n          appPublishers[event] ||\n          // 4. App publisher for all events\n          appPublishers[mixins_1.keys.ALL_EVENTS] ||\n          // 5. No publisher\n          lodash_1.noop;\n          try {\n            Promise.resolve(publisher(data, hook)).then(result => {\n              if (!result) {\n                return;\n              }\n              const results = Array.isArray(result) ? (0, lodash_1.compact)((0, lodash_1.flattenDeep)(result)) : [result];\n              const channel = new combined_1.CombinedChannel(results);\n              if (channel && channel.length > 0) {\n                app.emit('publish', event, channel, hook, data);\n              } else {\n                debug('No connections to publish to');\n              }\n            }).catch(logError);\n          } catch (error) {\n            logError(error);\n          }\n        });\n      });\n    });\n  };\n}\nexports.channels = channels;","map":{"version":3,"names":["feathers_1","require","commons_1","lodash_1","base_1","Object","defineProperty","exports","enumerable","get","Channel","combined_1","CombinedChannel","mixins_1","keys","debug","createDebug","CHANNELS","channels","app","channel","publish","assign","channelMixin","publishMixin","mixins","push","service","path","serviceEvents","getServiceOptions","forEach","event","on","data","hook","result","logError","error","servicePublishers","PUBLISHERS","appPublishers","publisher","ALL_EVENTS","noop","Promise","resolve","then","results","Array","isArray","compact","flattenDeep","length","emit","catch"],"sources":["C:\\Users\\VARLab ROG 1\\Documents\\workspace\\web\\react-frontend\\node_modules\\@feathersjs\\transport-commons\\src\\channels\\index.ts"],"sourcesContent":["import { Application, FeathersService, RealTimeConnection, getServiceOptions } from '@feathersjs/feathers'\nimport { createDebug } from '@feathersjs/commons'\nimport { compact, flattenDeep, noop } from 'lodash'\nimport { Channel } from './channel/base'\nimport { CombinedChannel } from './channel/combined'\nimport { channelMixin, publishMixin, keys, PublishMixin, Event, Publisher } from './mixins'\nimport EventEmitter from 'events'\n\nconst debug = createDebug('@feathersjs/transport-commons/channels')\nconst { CHANNELS } = keys\n\ndeclare module '@feathersjs/feathers/lib/declarations' {\n  interface ServiceAddons<A, S> extends EventEmitter {\n    // eslint-disable-line\n    publish(publisher: Publisher<ServiceGenericType<S>, A, this>): this\n    publish(event: Event, publisher: Publisher<ServiceGenericType<S>, A, this>): this\n\n    registerPublisher(publisher: Publisher<ServiceGenericType<S>, A, this>): this\n    registerPublisher(event: Event, publisher: Publisher<ServiceGenericType<S>, A, this>): this\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  interface Application<Services, Settings> {\n    // eslint-disable-line\n    channels: string[]\n\n    channel(name: string | string[]): Channel\n    channel(...names: string[]): Channel\n\n    publish<T>(publisher: Publisher<T, this>): this\n    publish<T>(event: Event, publisher: Publisher<T, this>): this\n\n    registerPublisher<T>(publisher: Publisher<T, this>): this\n    registerPublisher<T>(event: Event, publisher: Publisher<T, this>): this\n  }\n\n  interface Params {\n    connection?: RealTimeConnection\n  }\n}\n\nexport { keys }\n\nexport function channels() {\n  return (app: Application) => {\n    if (typeof app.channel === 'function' && typeof app.publish === 'function') {\n      return\n    }\n\n    Object.assign(app, channelMixin(), publishMixin())\n    Object.defineProperty(app, 'channels', {\n      get() {\n        return Object.keys(this[CHANNELS])\n      }\n    })\n\n    app.mixins.push((service: FeathersService, path: string) => {\n      const { serviceEvents } = getServiceOptions(service)\n\n      if (typeof service.publish === 'function') {\n        return\n      }\n\n      Object.assign(service, publishMixin())\n\n      serviceEvents.forEach((event: string) => {\n        service.on(event, function (data, hook) {\n          if (!hook) {\n            // Fake hook for custom events\n            hook = { path, service, app, result: data }\n          }\n\n          debug('Publishing event', event, hook.path)\n\n          const logError = (error: any) => debug(`Error in '${hook.path} ${event}' publisher`, error)\n          const servicePublishers = (service as unknown as PublishMixin)[keys.PUBLISHERS]\n          const appPublishers = (app as unknown as PublishMixin)[keys.PUBLISHERS]\n          // This will return the first publisher list that is not empty\n          // In the following precedence\n          const publisher =\n            // 1. Service publisher for a specific event\n            servicePublishers[event] ||\n            // 2. Service publisher for all events\n            servicePublishers[keys.ALL_EVENTS] ||\n            // 3. App publisher for a specific event\n            appPublishers[event] ||\n            // 4. App publisher for all events\n            appPublishers[keys.ALL_EVENTS] ||\n            // 5. No publisher\n            noop\n\n          try {\n            Promise.resolve(publisher(data, hook))\n              .then((result: any) => {\n                if (!result) {\n                  return\n                }\n\n                const results = Array.isArray(result) ? compact(flattenDeep(result)) : ([result] as Channel[])\n                const channel = new CombinedChannel(results)\n\n                if (channel && channel.length > 0) {\n                  app.emit('publish', event, channel, hook, data)\n                } else {\n                  debug('No connections to publish to')\n                }\n              })\n              .catch(logError)\n          } catch (error: any) {\n            logError(error)\n          }\n        })\n      })\n    })\n  }\n}\n\nexport { Channel, CombinedChannel, RealTimeConnection }\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}