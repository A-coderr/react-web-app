{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolve = exports.Resolver = exports.virtual = exports.IS_VIRTUAL = void 0;\nconst errors_1 = require(\"@feathersjs/errors\");\nexports.IS_VIRTUAL = Symbol.for('@feathersjs/schema/virtual');\n/**\n * Create a resolver for a virtual property. A virtual property is a property that\n * is computed and never has an initial value.\n *\n * @param virtualResolver The virtual resolver function\n * @returns The property resolver function\n */\nconst virtual = virtualResolver => {\n  const propertyResolver = async (_value, obj, context, status) => virtualResolver(obj, context, status);\n  propertyResolver[exports.IS_VIRTUAL] = true;\n  return propertyResolver;\n};\nexports.virtual = virtual;\nclass Resolver {\n  constructor(options) {\n    this.options = options;\n    this.propertyNames = Object.keys(options.properties);\n    this.virtualNames = this.propertyNames.filter(name => options.properties[name][exports.IS_VIRTUAL]);\n  }\n  /**\n   * Resolve a single property\n   *\n   * @param name The name of the property\n   * @param data The current data\n   * @param context The current resolver context\n   * @param status The current resolver status\n   * @returns The resolver property\n   */\n  async resolveProperty(name, data, context, status = {}) {\n    const resolver = this.options.properties[name];\n    const value = data[name];\n    const {\n      path = [],\n      stack = []\n    } = status || {};\n    // This prevents circular dependencies\n    if (stack.includes(resolver)) {\n      return undefined;\n    }\n    const resolverStatus = {\n      ...status,\n      path: [...path, name],\n      stack: [...stack, resolver]\n    };\n    return resolver(value, data, context, resolverStatus);\n  }\n  async convert(data, context, status) {\n    if (this.options.converter) {\n      const {\n        path = [],\n        stack = []\n      } = status || {};\n      return this.options.converter(data, context, {\n        ...status,\n        path,\n        stack\n      });\n    }\n    return data;\n  }\n  async resolve(_data, context, status) {\n    const {\n      properties: resolvers,\n      schema,\n      validate\n    } = this.options;\n    const payload = await this.convert(_data, context, status);\n    if (!Array.isArray(status === null || status === void 0 ? void 0 : status.properties) && this.propertyNames.length === 0) {\n      return payload;\n    }\n    const data = schema && validate === 'before' ? await schema.validate(payload) : payload;\n    const propertyList = Array.isArray(status === null || status === void 0 ? void 0 : status.properties) ? status === null || status === void 0 ? void 0 : status.properties :\n    // By default get all data and resolver keys but remove duplicates\n    [...new Set(Object.keys(data).concat(this.propertyNames))];\n    const result = {};\n    const errors = {};\n    let hasErrors = false;\n    // Not the most elegant but better performance\n    await Promise.all(propertyList.map(async name => {\n      const value = data[name];\n      if (resolvers[name]) {\n        try {\n          const resolved = await this.resolveProperty(name, data, context, status);\n          if (resolved !== undefined) {\n            result[name] = resolved;\n          }\n        } catch (error) {\n          // TODO add error stacks\n          const convertedError = typeof error.toJSON === 'function' ? error.toJSON() : {\n            message: error.message || error\n          };\n          errors[name] = convertedError;\n          hasErrors = true;\n        }\n      } else if (value !== undefined) {\n        result[name] = value;\n      }\n    }));\n    if (hasErrors) {\n      const propertyName = (status === null || status === void 0 ? void 0 : status.properties) ? ` ${status.properties.join('.')}` : '';\n      throw new errors_1.BadRequest('Error resolving data' + (propertyName ? ` ${propertyName}` : ''), errors);\n    }\n    return schema && validate === 'after' ? await schema.validate(result) : result;\n  }\n}\nexports.Resolver = Resolver;\nfunction resolve(properties, options) {\n  const settings = properties.properties ? properties : {\n    properties,\n    ...options\n  };\n  return new Resolver(settings);\n}\nexports.resolve = resolve;","map":{"version":3,"names":["errors_1","require","exports","IS_VIRTUAL","Symbol","for","virtual","virtualResolver","propertyResolver","_value","obj","context","status","Resolver","constructor","options","propertyNames","Object","keys","properties","virtualNames","filter","name","resolveProperty","data","resolver","value","path","stack","includes","undefined","resolverStatus","convert","converter","resolve","_data","resolvers","schema","validate","payload","Array","isArray","length","propertyList","Set","concat","result","errors","hasErrors","Promise","all","map","resolved","error","convertedError","toJSON","message","propertyName","join","BadRequest","settings"],"sources":["C:\\Users\\VARLab ROG 1\\Documents\\workspace\\web\\react-frontend\\node_modules\\@feathersjs\\authentication\\node_modules\\@feathersjs\\schema\\src\\resolver.ts"],"sourcesContent":["import { BadRequest } from '@feathersjs/errors'\nimport { Schema } from './schema'\n\nexport type PropertyResolver<T, V, C> = ((\n  value: V | undefined,\n  obj: T,\n  context: C,\n  status: ResolverStatus<T, C>\n) => Promise<V | undefined>) & { [IS_VIRTUAL]?: boolean }\n\nexport type VirtualResolver<T, V, C> = (\n  obj: T,\n  context: C,\n  status: ResolverStatus<T, C>\n) => Promise<V | undefined>\n\nexport const IS_VIRTUAL = Symbol.for('@feathersjs/schema/virtual')\n\n/**\n * Create a resolver for a virtual property. A virtual property is a property that\n * is computed and never has an initial value.\n *\n * @param virtualResolver The virtual resolver function\n * @returns The property resolver function\n */\nexport const virtual = <T, V, C>(virtualResolver: VirtualResolver<T, V, C>) => {\n  const propertyResolver: PropertyResolver<T, V, C> = async (_value, obj, context, status) =>\n    virtualResolver(obj, context, status)\n\n  propertyResolver[IS_VIRTUAL] = true\n\n  return propertyResolver\n}\n\nexport type PropertyResolverMap<T, C> = {\n  [key in keyof T]?: PropertyResolver<T, T[key], C> | ReturnType<typeof virtual<T, T[key], C>>\n}\n\nexport type ResolverConverter<T, C> = (\n  obj: any,\n  context: C,\n  status: ResolverStatus<T, C>\n) => Promise<T | undefined>\n\nexport interface ResolverOptions<T, C> {\n  schema?: Schema<T>\n  /**\n   * A converter function that is run before property resolvers\n   * to transform the initial data into a different format.\n   */\n  converter?: ResolverConverter<T, C>\n}\n\nexport interface ResolverConfig<T, C> extends ResolverOptions<T, C> {\n  /**\n   * @deprecated Use the `validateData` and `validateQuery` hooks explicitly instead\n   */\n  validate?: 'before' | 'after' | false\n  /**\n   * The properties to resolve\n   */\n  properties: PropertyResolverMap<T, C>\n}\n\nexport interface ResolverStatus<T, C> {\n  path: string[]\n  originalContext?: C\n  properties?: (keyof T)[]\n  stack: PropertyResolver<T, any, C>[]\n}\n\nexport class Resolver<T, C> {\n  readonly _type!: T\n  public propertyNames: (keyof T)[]\n  public virtualNames: (keyof T)[]\n\n  constructor(public readonly options: ResolverConfig<T, C>) {\n    this.propertyNames = Object.keys(options.properties) as any as (keyof T)[]\n    this.virtualNames = this.propertyNames.filter((name) => options.properties[name][IS_VIRTUAL])\n  }\n\n  /**\n   * Resolve a single property\n   *\n   * @param name The name of the property\n   * @param data The current data\n   * @param context The current resolver context\n   * @param status The current resolver status\n   * @returns The resolver property\n   */\n  async resolveProperty<D, K extends keyof T>(\n    name: K,\n    data: D,\n    context: C,\n    status: Partial<ResolverStatus<T, C>> = {}\n  ): Promise<T[K]> {\n    const resolver = this.options.properties[name]\n    const value = (data as any)[name]\n    const { path = [], stack = [] } = status || {}\n\n    // This prevents circular dependencies\n    if (stack.includes(resolver)) {\n      return undefined\n    }\n\n    const resolverStatus = {\n      ...status,\n      path: [...path, name as string],\n      stack: [...stack, resolver]\n    }\n\n    return resolver(value, data as any, context, resolverStatus)\n  }\n\n  async convert<D>(data: D, context: C, status?: Partial<ResolverStatus<T, C>>) {\n    if (this.options.converter) {\n      const { path = [], stack = [] } = status || {}\n\n      return this.options.converter(data, context, { ...status, path, stack })\n    }\n\n    return data\n  }\n\n  async resolve<D>(_data: D, context: C, status?: Partial<ResolverStatus<T, C>>): Promise<T> {\n    const { properties: resolvers, schema, validate } = this.options\n    const payload = await this.convert(_data, context, status)\n\n    if (!Array.isArray(status?.properties) && this.propertyNames.length === 0) {\n      return payload as T\n    }\n\n    const data = schema && validate === 'before' ? await schema.validate(payload) : payload\n    const propertyList = (\n      Array.isArray(status?.properties)\n        ? status?.properties\n        : // By default get all data and resolver keys but remove duplicates\n          [...new Set(Object.keys(data).concat(this.propertyNames as string[]))]\n    ) as (keyof T)[]\n\n    const result: any = {}\n    const errors: any = {}\n    let hasErrors = false\n\n    // Not the most elegant but better performance\n    await Promise.all(\n      propertyList.map(async (name) => {\n        const value = (data as any)[name]\n\n        if (resolvers[name]) {\n          try {\n            const resolved = await this.resolveProperty(name, data, context, status)\n\n            if (resolved !== undefined) {\n              result[name] = resolved\n            }\n          } catch (error: any) {\n            // TODO add error stacks\n            const convertedError =\n              typeof error.toJSON === 'function' ? error.toJSON() : { message: error.message || error }\n\n            errors[name] = convertedError\n            hasErrors = true\n          }\n        } else if (value !== undefined) {\n          result[name] = value\n        }\n      })\n    )\n\n    if (hasErrors) {\n      const propertyName = status?.properties ? ` ${status.properties.join('.')}` : ''\n\n      throw new BadRequest('Error resolving data' + (propertyName ? ` ${propertyName}` : ''), errors)\n    }\n\n    return schema && validate === 'after' ? await schema.validate(result) : result\n  }\n}\n\n/**\n * Create a new resolver with `<DataType, ContextType>`.\n *\n * @param options The configuration for the returned resolver\n * @returns A new resolver instance\n */\nexport function resolve<T, C>(\n  properties: PropertyResolverMap<T, C>,\n  options?: ResolverOptions<T, C>\n): Resolver<T, C>\nexport function resolve<T, C>(options: ResolverConfig<T, C>): Resolver<T, C>\nexport function resolve<T, C>(\n  properties: PropertyResolverMap<T, C> | ResolverConfig<T, C>,\n  options?: ResolverOptions<T, C>\n) {\n  const settings = (\n    (properties as ResolverConfig<T, C>).properties ? properties : { properties, ...options }\n  ) as ResolverConfig<T, C>\n\n  return new Resolver<T, C>(settings)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}