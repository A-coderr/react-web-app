{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.runMethod = exports.getDispatcher = exports.normalizeError = exports.paramsPositions = exports.DEFAULT_PARAMS_POSITION = void 0;\nconst feathers_1 = require(\"@feathersjs/feathers\");\nconst errors_1 = require(\"@feathersjs/errors\");\nconst commons_1 = require(\"@feathersjs/commons\");\nconst isEqual_1 = __importDefault(require(\"lodash/isEqual\"));\nconst debug = (0, commons_1.createDebug)('@feathersjs/transport-commons');\nexports.DEFAULT_PARAMS_POSITION = 1;\nexports.paramsPositions = {\n  find: 0,\n  update: 2,\n  patch: 2\n};\nfunction normalizeError(e) {\n  const hasToJSON = typeof e.toJSON === 'function';\n  const result = hasToJSON ? e.toJSON() : {};\n  if (!hasToJSON) {\n    Object.getOwnPropertyNames(e).forEach(key => {\n      result[key] = e[key];\n    });\n  }\n  if (process.env.NODE_ENV === 'production') {\n    delete result.stack;\n  }\n  delete result.hook;\n  return result;\n}\nexports.normalizeError = normalizeError;\nfunction getDispatcher(emit, socketMap, socketKey) {\n  return function (event, channel, context, data) {\n    debug(`Dispatching '${event}' to ${channel.length} connections`);\n    channel.connections.forEach(connection => {\n      // The reference between connection and socket is set in `app.setup`\n      const socket = socketKey ? connection[socketKey] : socketMap.get(connection);\n      if (socket) {\n        const eventName = `${context.path || ''} ${event}`.trim();\n        let result = channel.dataFor(connection) || context.dispatch || context.result;\n        // If we are getting events from an array but try to dispatch individual data\n        // try to get the individual item to dispatch from the correct index.\n        if (!Array.isArray(data) && Array.isArray(context.result) && Array.isArray(result)) {\n          result = result.find(resultData => (0, isEqual_1.default)(resultData, data));\n        }\n        debug(`Dispatching '${eventName}' to Socket ${socket.id} with`, result);\n        socket[emit](eventName, result);\n      }\n    });\n  };\n}\nexports.getDispatcher = getDispatcher;\nasync function runMethod(app, connection, _path, _method, args) {\n  const path = typeof _path === 'string' ? _path : null;\n  const method = typeof _method === 'string' ? _method : null;\n  const trace = `method '${method}' on service '${path}'`;\n  const methodArgs = args.slice(0);\n  const callback =\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  typeof methodArgs[methodArgs.length - 1] === 'function' ? methodArgs.pop() : function () {};\n  debug(`Running ${trace}`, connection, args);\n  const handleError = error => {\n    debug(`Error in ${trace}`, error);\n    callback(normalizeError(error));\n  };\n  try {\n    const lookup = app.lookup(path);\n    // No valid service was found throw a NotFound error\n    if (lookup === null) {\n      throw new errors_1.NotFound(path === null ? `Invalid service path` : `Service '${path}' not found`);\n    }\n    const {\n      service,\n      params: route = {}\n    } = lookup;\n    const {\n      methods\n    } = (0, feathers_1.getServiceOptions)(service);\n    // Only service methods are allowed\n    if (!methods.includes(method)) {\n      throw new errors_1.MethodNotAllowed(`Method '${method}' not allowed on service '${path}'`);\n    }\n    const position = exports.paramsPositions[method] !== undefined ? exports.paramsPositions[method] : exports.DEFAULT_PARAMS_POSITION;\n    const query = Object.assign({}, methodArgs[position]);\n    // `params` have to be re-mapped to the query and added with the route\n    const params = Object.assign({\n      query,\n      route,\n      connection\n    }, connection);\n    // `params` is always the last parameter. Error if we got more arguments.\n    if (methodArgs.length > position + 1) {\n      throw new errors_1.BadRequest(`Too many arguments for '${method}' method`);\n    }\n    methodArgs[position] = params;\n    const ctx = (0, feathers_1.createContext)(service, method);\n    const returnedCtx = await service[method](...methodArgs, ctx);\n    const result = returnedCtx.dispatch || returnedCtx.result;\n    debug(`Returned successfully ${trace}`, result);\n    callback(null, result);\n  } catch (error) {\n    handleError(error);\n  }\n}\nexports.runMethod = runMethod;","map":{"version":3,"names":["feathers_1","require","errors_1","commons_1","isEqual_1","__importDefault","debug","createDebug","exports","DEFAULT_PARAMS_POSITION","paramsPositions","find","update","patch","normalizeError","e","hasToJSON","toJSON","result","Object","getOwnPropertyNames","forEach","key","process","env","NODE_ENV","stack","hook","getDispatcher","emit","socketMap","socketKey","event","channel","context","data","length","connections","connection","socket","get","eventName","path","trim","dataFor","dispatch","Array","isArray","resultData","default","id","runMethod","app","_path","_method","args","method","trace","methodArgs","slice","callback","pop","handleError","error","lookup","NotFound","service","params","route","methods","getServiceOptions","includes","MethodNotAllowed","position","undefined","query","assign","BadRequest","ctx","createContext","returnedCtx"],"sources":["C:\\Users\\VARLab ROG 1\\Documents\\workspace\\web\\react-frontend\\node_modules\\@feathersjs\\transport-commons\\src\\socket\\utils.ts"],"sourcesContent":["import {\n  HookContext,\n  Application,\n  RealTimeConnection,\n  createContext,\n  getServiceOptions\n} from '@feathersjs/feathers'\nimport { NotFound, MethodNotAllowed, BadRequest } from '@feathersjs/errors'\nimport { createDebug } from '@feathersjs/commons'\nimport isEqual from 'lodash/isEqual'\nimport { CombinedChannel } from '../channels/channel/combined'\n\nconst debug = createDebug('@feathersjs/transport-commons')\n\nexport const DEFAULT_PARAMS_POSITION = 1\n\nexport const paramsPositions: { [key: string]: number } = {\n  find: 0,\n  update: 2,\n  patch: 2\n}\n\nexport function normalizeError(e: any) {\n  const hasToJSON = typeof e.toJSON === 'function'\n  const result = hasToJSON ? e.toJSON() : {}\n\n  if (!hasToJSON) {\n    Object.getOwnPropertyNames(e).forEach((key) => {\n      result[key] = e[key]\n    })\n  }\n\n  if (process.env.NODE_ENV === 'production') {\n    delete result.stack\n  }\n\n  delete result.hook\n\n  return result\n}\n\nexport function getDispatcher(emit: string, socketMap: WeakMap<RealTimeConnection, any>, socketKey?: any) {\n  return function (event: string, channel: CombinedChannel, context: HookContext, data?: any) {\n    debug(`Dispatching '${event}' to ${channel.length} connections`)\n\n    channel.connections.forEach((connection) => {\n      // The reference between connection and socket is set in `app.setup`\n      const socket = socketKey ? connection[socketKey] : socketMap.get(connection)\n\n      if (socket) {\n        const eventName = `${context.path || ''} ${event}`.trim()\n\n        let result = channel.dataFor(connection) || context.dispatch || context.result\n\n        // If we are getting events from an array but try to dispatch individual data\n        // try to get the individual item to dispatch from the correct index.\n        if (!Array.isArray(data) && Array.isArray(context.result) && Array.isArray(result)) {\n          result = result.find((resultData) => isEqual(resultData, data))\n        }\n\n        debug(`Dispatching '${eventName}' to Socket ${socket.id} with`, result)\n\n        socket[emit](eventName, result)\n      }\n    })\n  }\n}\n\nexport async function runMethod(\n  app: Application,\n  connection: RealTimeConnection,\n  _path: string,\n  _method: string,\n  args: any[]\n) {\n  const path = typeof _path === 'string' ? _path : null\n  const method = typeof _method === 'string' ? _method : null\n  const trace = `method '${method}' on service '${path}'`\n  const methodArgs = args.slice(0)\n  const callback =\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    typeof methodArgs[methodArgs.length - 1] === 'function' ? methodArgs.pop() : function () {}\n\n  debug(`Running ${trace}`, connection, args)\n\n  const handleError = (error: any) => {\n    debug(`Error in ${trace}`, error)\n    callback(normalizeError(error))\n  }\n\n  try {\n    const lookup = app.lookup(path)\n\n    // No valid service was found throw a NotFound error\n    if (lookup === null) {\n      throw new NotFound(path === null ? `Invalid service path` : `Service '${path}' not found`)\n    }\n\n    const { service, params: route = {} } = lookup\n    const { methods } = getServiceOptions(service)\n\n    // Only service methods are allowed\n    if (!methods.includes(method)) {\n      throw new MethodNotAllowed(`Method '${method}' not allowed on service '${path}'`)\n    }\n\n    const position = paramsPositions[method] !== undefined ? paramsPositions[method] : DEFAULT_PARAMS_POSITION\n    const query = Object.assign({}, methodArgs[position])\n    // `params` have to be re-mapped to the query and added with the route\n    const params = Object.assign({ query, route, connection }, connection)\n\n    // `params` is always the last parameter. Error if we got more arguments.\n    if (methodArgs.length > position + 1) {\n      throw new BadRequest(`Too many arguments for '${method}' method`)\n    }\n\n    methodArgs[position] = params\n\n    const ctx = createContext(service, method)\n    const returnedCtx: HookContext = await (service as any)[method](...methodArgs, ctx)\n    const result = returnedCtx.dispatch || returnedCtx.result\n\n    debug(`Returned successfully ${trace}`, result)\n    callback(null, result)\n  } catch (error: any) {\n    handleError(error)\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}