{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JWTStrategy = void 0;\n/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/ban-ts-comment */\nconst omit_1 = __importDefault(require(\"lodash/omit\"));\nconst errors_1 = require(\"@feathersjs/errors\");\nconst commons_1 = require(\"@feathersjs/commons\");\n// @ts-ignore\nconst long_timeout_1 = __importDefault(require(\"long-timeout\"));\nconst strategy_1 = require(\"./strategy\");\nconst debug = (0, commons_1.createDebug)('@feathersjs/authentication/jwt');\nconst SPLIT_HEADER = /(\\S+)\\s+(\\S+)/;\nclass JWTStrategy extends strategy_1.AuthenticationBaseStrategy {\n  constructor() {\n    super(...arguments);\n    this.expirationTimers = new WeakMap();\n  }\n  get configuration() {\n    const authConfig = this.authentication.configuration;\n    const config = super.configuration;\n    return {\n      service: authConfig.service,\n      entity: authConfig.entity,\n      entityId: authConfig.entityId,\n      header: 'Authorization',\n      schemes: ['Bearer', 'JWT'],\n      ...config\n    };\n  }\n  async handleConnection(event, connection, authResult) {\n    var _a;\n    const isValidLogout = event === 'logout' && connection.authentication && authResult && connection.authentication.accessToken === authResult.accessToken;\n    const {\n      accessToken\n    } = authResult || {};\n    const {\n      entity\n    } = this.configuration;\n    if (accessToken && event === 'login') {\n      debug('Adding authentication information to connection');\n      const {\n        exp\n      } = ((_a = authResult === null || authResult === void 0 ? void 0 : authResult.authentication) === null || _a === void 0 ? void 0 : _a.payload) || (await this.authentication.verifyAccessToken(accessToken));\n      // The time (in ms) until the token expires\n      const duration = exp * 1000 - Date.now();\n      const timer = long_timeout_1.default.setTimeout(() => this.app.emit('disconnect', connection), duration);\n      debug(`Registering connection expiration timer for ${duration}ms`);\n      long_timeout_1.default.clearTimeout(this.expirationTimers.get(connection));\n      this.expirationTimers.set(connection, timer);\n      debug('Adding authentication information to connection');\n      connection.authentication = {\n        strategy: this.name,\n        accessToken\n      };\n      connection[entity] = authResult[entity];\n    } else if (event === 'disconnect' || isValidLogout) {\n      debug('Removing authentication information and expiration timer from connection');\n      await new Promise(resolve => process.nextTick(() => {\n        delete connection[entity];\n        delete connection.authentication;\n        resolve(connection);\n      }));\n      long_timeout_1.default.clearTimeout(this.expirationTimers.get(connection));\n      this.expirationTimers.delete(connection);\n    }\n  }\n  verifyConfiguration() {\n    const allowedKeys = ['entity', 'entityId', 'service', 'header', 'schemes'];\n    for (const key of Object.keys(this.configuration)) {\n      if (!allowedKeys.includes(key)) {\n        throw new Error(`Invalid JwtStrategy option 'authentication.${this.name}.${key}'. Did you mean to set it in 'authentication.jwtOptions'?`);\n      }\n    }\n    if (typeof this.configuration.header !== 'string') {\n      throw new Error(`The 'header' option for the ${this.name} strategy must be a string`);\n    }\n  }\n  async getEntityQuery(_params) {\n    return {};\n  }\n  /**\n   * Return the entity for a given id\n   *\n   * @param id The id to use\n   * @param params Service call parameters\n   */\n  async getEntity(id, params) {\n    const entityService = this.entityService;\n    const {\n      entity\n    } = this.configuration;\n    debug('Getting entity', id);\n    if (entityService === null) {\n      throw new errors_1.NotAuthenticated('Could not find entity service');\n    }\n    const query = await this.getEntityQuery(params);\n    const getParams = Object.assign({}, (0, omit_1.default)(params, 'provider'), {\n      query\n    });\n    const result = await entityService.get(id, getParams);\n    if (!params.provider) {\n      return result;\n    }\n    return entityService.get(id, {\n      ...params,\n      [entity]: result\n    });\n  }\n  async getEntityId(authResult, _params) {\n    return authResult.authentication.payload.sub;\n  }\n  async authenticate(authentication, params) {\n    const {\n      accessToken\n    } = authentication;\n    const {\n      entity\n    } = this.configuration;\n    if (!accessToken) {\n      throw new errors_1.NotAuthenticated('No access token');\n    }\n    const payload = await this.authentication.verifyAccessToken(accessToken, params.jwt);\n    const result = {\n      accessToken,\n      authentication: {\n        strategy: 'jwt',\n        accessToken,\n        payload\n      }\n    };\n    if (entity === null) {\n      return result;\n    }\n    const entityId = await this.getEntityId(result, params);\n    const value = await this.getEntity(entityId, params);\n    return {\n      ...result,\n      [entity]: value\n    };\n  }\n  async parse(req) {\n    const {\n      header,\n      schemes\n    } = this.configuration;\n    const headerValue = req.headers && req.headers[header.toLowerCase()];\n    if (!headerValue || typeof headerValue !== 'string') {\n      return null;\n    }\n    debug('Found parsed header value');\n    const [, scheme, schemeValue] = headerValue.match(SPLIT_HEADER) || [];\n    const hasScheme = scheme && schemes.some(current => new RegExp(current, 'i').test(scheme));\n    if (scheme && !hasScheme) {\n      return null;\n    }\n    return {\n      strategy: this.name,\n      accessToken: hasScheme ? schemeValue : headerValue\n    };\n  }\n}\nexports.JWTStrategy = JWTStrategy;","map":{"version":3,"names":["omit_1","__importDefault","require","errors_1","commons_1","long_timeout_1","strategy_1","debug","createDebug","SPLIT_HEADER","JWTStrategy","AuthenticationBaseStrategy","constructor","expirationTimers","WeakMap","configuration","authConfig","authentication","config","service","entity","entityId","header","schemes","handleConnection","event","connection","authResult","isValidLogout","accessToken","exp","_a","payload","verifyAccessToken","duration","Date","now","timer","default","setTimeout","app","emit","clearTimeout","get","set","strategy","name","Promise","resolve","process","nextTick","delete","verifyConfiguration","allowedKeys","key","Object","keys","includes","Error","getEntityQuery","_params","getEntity","id","params","entityService","NotAuthenticated","query","getParams","assign","result","provider","getEntityId","sub","authenticate","jwt","value","parse","req","headerValue","headers","toLowerCase","scheme","schemeValue","match","hasScheme","some","current","RegExp","test","exports"],"sources":["C:\\Users\\VARLab ROG 1\\Documents\\workspace\\web\\react-frontend\\node_modules\\@feathersjs\\authentication\\src\\jwt.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/ban-ts-comment */\nimport omit from 'lodash/omit'\nimport { IncomingMessage } from 'http'\nimport { NotAuthenticated } from '@feathersjs/errors'\nimport { Params } from '@feathersjs/feathers'\nimport { createDebug } from '@feathersjs/commons'\n// @ts-ignore\nimport lt from 'long-timeout'\n\nimport { AuthenticationBaseStrategy } from './strategy'\nimport { AuthenticationParams, AuthenticationRequest, AuthenticationResult, ConnectionEvent } from './core'\n\nconst debug = createDebug('@feathersjs/authentication/jwt')\nconst SPLIT_HEADER = /(\\S+)\\s+(\\S+)/\n\nexport class JWTStrategy extends AuthenticationBaseStrategy {\n  expirationTimers = new WeakMap()\n\n  get configuration() {\n    const authConfig = this.authentication.configuration\n    const config = super.configuration\n\n    return {\n      service: authConfig.service,\n      entity: authConfig.entity,\n      entityId: authConfig.entityId,\n      header: 'Authorization',\n      schemes: ['Bearer', 'JWT'],\n      ...config\n    }\n  }\n\n  async handleConnection(\n    event: ConnectionEvent,\n    connection: any,\n    authResult?: AuthenticationResult\n  ): Promise<void> {\n    const isValidLogout =\n      event === 'logout' &&\n      connection.authentication &&\n      authResult &&\n      connection.authentication.accessToken === authResult.accessToken\n\n    const { accessToken } = authResult || {}\n    const { entity } = this.configuration\n\n    if (accessToken && event === 'login') {\n      debug('Adding authentication information to connection')\n      const { exp } =\n        authResult?.authentication?.payload || (await this.authentication.verifyAccessToken(accessToken))\n      // The time (in ms) until the token expires\n      const duration = exp * 1000 - Date.now()\n      const timer = lt.setTimeout(() => this.app.emit('disconnect', connection), duration)\n\n      debug(`Registering connection expiration timer for ${duration}ms`)\n      lt.clearTimeout(this.expirationTimers.get(connection))\n      this.expirationTimers.set(connection, timer)\n\n      debug('Adding authentication information to connection')\n      connection.authentication = {\n        strategy: this.name,\n        accessToken\n      }\n      connection[entity] = authResult[entity]\n    } else if (event === 'disconnect' || isValidLogout) {\n      debug('Removing authentication information and expiration timer from connection')\n\n      await new Promise((resolve) =>\n        process.nextTick(() => {\n          delete connection[entity]\n          delete connection.authentication\n          resolve(connection)\n        })\n      )\n\n      lt.clearTimeout(this.expirationTimers.get(connection))\n      this.expirationTimers.delete(connection)\n    }\n  }\n\n  verifyConfiguration() {\n    const allowedKeys = ['entity', 'entityId', 'service', 'header', 'schemes']\n\n    for (const key of Object.keys(this.configuration)) {\n      if (!allowedKeys.includes(key)) {\n        throw new Error(\n          `Invalid JwtStrategy option 'authentication.${this.name}.${key}'. Did you mean to set it in 'authentication.jwtOptions'?`\n        )\n      }\n    }\n\n    if (typeof this.configuration.header !== 'string') {\n      throw new Error(`The 'header' option for the ${this.name} strategy must be a string`)\n    }\n  }\n\n  async getEntityQuery(_params: Params) {\n    return {}\n  }\n\n  /**\n   * Return the entity for a given id\n   *\n   * @param id The id to use\n   * @param params Service call parameters\n   */\n  async getEntity(id: string, params: Params) {\n    const entityService = this.entityService\n    const { entity } = this.configuration\n\n    debug('Getting entity', id)\n\n    if (entityService === null) {\n      throw new NotAuthenticated('Could not find entity service')\n    }\n\n    const query = await this.getEntityQuery(params)\n    const getParams = Object.assign({}, omit(params, 'provider'), { query })\n    const result = await entityService.get(id, getParams)\n\n    if (!params.provider) {\n      return result\n    }\n\n    return entityService.get(id, { ...params, [entity]: result })\n  }\n\n  async getEntityId(authResult: AuthenticationResult, _params: Params) {\n    return authResult.authentication.payload.sub\n  }\n\n  async authenticate(authentication: AuthenticationRequest, params: AuthenticationParams) {\n    const { accessToken } = authentication\n    const { entity } = this.configuration\n\n    if (!accessToken) {\n      throw new NotAuthenticated('No access token')\n    }\n\n    const payload = await this.authentication.verifyAccessToken(accessToken, params.jwt)\n    const result = {\n      accessToken,\n      authentication: {\n        strategy: 'jwt',\n        accessToken,\n        payload\n      }\n    }\n\n    if (entity === null) {\n      return result\n    }\n\n    const entityId = await this.getEntityId(result, params)\n    const value = await this.getEntity(entityId, params)\n\n    return {\n      ...result,\n      [entity]: value\n    }\n  }\n\n  async parse(req: IncomingMessage): Promise<{\n    strategy: string\n    accessToken: string\n  } | null> {\n    const { header, schemes }: { header: string; schemes: string[] } = this.configuration\n    const headerValue = req.headers && req.headers[header.toLowerCase()]\n\n    if (!headerValue || typeof headerValue !== 'string') {\n      return null\n    }\n\n    debug('Found parsed header value')\n\n    const [, scheme, schemeValue] = headerValue.match(SPLIT_HEADER) || []\n    const hasScheme = scheme && schemes.some((current) => new RegExp(current, 'i').test(scheme))\n\n    if (scheme && !hasScheme) {\n      return null\n    }\n\n    return {\n      strategy: this.name,\n      accessToken: hasScheme ? schemeValue : headerValue\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;;AAAA;AACA,MAAAA,MAAA,GAAAC,eAAA,CAAAC,OAAA;AAEA,MAAAC,QAAA,GAAAD,OAAA;AAEA,MAAAE,SAAA,GAAAF,OAAA;AACA;AACA,MAAAG,cAAA,GAAAJ,eAAA,CAAAC,OAAA;AAEA,MAAAI,UAAA,GAAAJ,OAAA;AAGA,MAAMK,KAAK,GAAG,IAAAH,SAAA,CAAAI,WAAW,EAAC,gCAAgC,CAAC;AAC3D,MAAMC,YAAY,GAAG,eAAe;AAEpC,MAAaC,WAAY,SAAQJ,UAAA,CAAAK,0BAA0B;EAA3DC,YAAA;;IACE,KAAAC,gBAAgB,GAAG,IAAIC,OAAO,EAAE;EA2KlC;EAzKE,IAAIC,aAAaA,CAAA;IACf,MAAMC,UAAU,GAAG,IAAI,CAACC,cAAc,CAACF,aAAa;IACpD,MAAMG,MAAM,GAAG,KAAK,CAACH,aAAa;IAElC,OAAO;MACLI,OAAO,EAAEH,UAAU,CAACG,OAAO;MAC3BC,MAAM,EAAEJ,UAAU,CAACI,MAAM;MACzBC,QAAQ,EAAEL,UAAU,CAACK,QAAQ;MAC7BC,MAAM,EAAE,eAAe;MACvBC,OAAO,EAAE,CAAC,QAAQ,EAAE,KAAK,CAAC;MAC1B,GAAGL;KACJ;EACH;EAEA,MAAMM,gBAAgBA,CACpBC,KAAsB,EACtBC,UAAe,EACfC,UAAiC;;IAEjC,MAAMC,aAAa,GACjBH,KAAK,KAAK,QAAQ,IAClBC,UAAU,CAACT,cAAc,IACzBU,UAAU,IACVD,UAAU,CAACT,cAAc,CAACY,WAAW,KAAKF,UAAU,CAACE,WAAW;IAElE,MAAM;MAAEA;IAAW,CAAE,GAAGF,UAAU,IAAI,EAAE;IACxC,MAAM;MAAEP;IAAM,CAAE,GAAG,IAAI,CAACL,aAAa;IAErC,IAAIc,WAAW,IAAIJ,KAAK,KAAK,OAAO,EAAE;MACpClB,KAAK,CAAC,iDAAiD,CAAC;MACxD,MAAM;QAAEuB;MAAG,CAAE,GACX,EAAAC,EAAA,GAAAJ,UAAU,aAAVA,UAAU,uBAAVA,UAAU,CAAEV,cAAc,cAAAc,EAAA,uBAAAA,EAAA,CAAEC,OAAO,MAAK,MAAM,IAAI,CAACf,cAAc,CAACgB,iBAAiB,CAACJ,WAAW,CAAC,CAAC;MACnG;MACA,MAAMK,QAAQ,GAAGJ,GAAG,GAAG,IAAI,GAAGK,IAAI,CAACC,GAAG,EAAE;MACxC,MAAMC,KAAK,GAAGhC,cAAA,CAAAiC,OAAE,CAACC,UAAU,CAAC,MAAM,IAAI,CAACC,GAAG,CAACC,IAAI,CAAC,YAAY,EAAEf,UAAU,CAAC,EAAEQ,QAAQ,CAAC;MAEpF3B,KAAK,CAAC,+CAA+C2B,QAAQ,IAAI,CAAC;MAClE7B,cAAA,CAAAiC,OAAE,CAACI,YAAY,CAAC,IAAI,CAAC7B,gBAAgB,CAAC8B,GAAG,CAACjB,UAAU,CAAC,CAAC;MACtD,IAAI,CAACb,gBAAgB,CAAC+B,GAAG,CAAClB,UAAU,EAAEW,KAAK,CAAC;MAE5C9B,KAAK,CAAC,iDAAiD,CAAC;MACxDmB,UAAU,CAACT,cAAc,GAAG;QAC1B4B,QAAQ,EAAE,IAAI,CAACC,IAAI;QACnBjB;OACD;MACDH,UAAU,CAACN,MAAM,CAAC,GAAGO,UAAU,CAACP,MAAM,CAAC;IACzC,CAAC,MAAM,IAAIK,KAAK,KAAK,YAAY,IAAIG,aAAa,EAAE;MAClDrB,KAAK,CAAC,0EAA0E,CAAC;MAEjF,MAAM,IAAIwC,OAAO,CAAEC,OAAO,IACxBC,OAAO,CAACC,QAAQ,CAAC,MAAK;QACpB,OAAOxB,UAAU,CAACN,MAAM,CAAC;QACzB,OAAOM,UAAU,CAACT,cAAc;QAChC+B,OAAO,CAACtB,UAAU,CAAC;MACrB,CAAC,CAAC,CACH;MAEDrB,cAAA,CAAAiC,OAAE,CAACI,YAAY,CAAC,IAAI,CAAC7B,gBAAgB,CAAC8B,GAAG,CAACjB,UAAU,CAAC,CAAC;MACtD,IAAI,CAACb,gBAAgB,CAACsC,MAAM,CAACzB,UAAU,CAAC;IAC1C;EACF;EAEA0B,mBAAmBA,CAAA;IACjB,MAAMC,WAAW,GAAG,CAAC,QAAQ,EAAE,UAAU,EAAE,SAAS,EAAE,QAAQ,EAAE,SAAS,CAAC;IAE1E,KAAK,MAAMC,GAAG,IAAIC,MAAM,CAACC,IAAI,CAAC,IAAI,CAACzC,aAAa,CAAC,EAAE;MACjD,IAAI,CAACsC,WAAW,CAACI,QAAQ,CAACH,GAAG,CAAC,EAAE;QAC9B,MAAM,IAAII,KAAK,CACb,8CAA8C,IAAI,CAACZ,IAAI,IAAIQ,GAAG,2DAA2D,CAC1H;MACH;IACF;IAEA,IAAI,OAAO,IAAI,CAACvC,aAAa,CAACO,MAAM,KAAK,QAAQ,EAAE;MACjD,MAAM,IAAIoC,KAAK,CAAC,+BAA+B,IAAI,CAACZ,IAAI,4BAA4B,CAAC;IACvF;EACF;EAEA,MAAMa,cAAcA,CAACC,OAAe;IAClC,OAAO,EAAE;EACX;EAEA;;;;;;EAMA,MAAMC,SAASA,CAACC,EAAU,EAAEC,MAAc;IACxC,MAAMC,aAAa,GAAG,IAAI,CAACA,aAAa;IACxC,MAAM;MAAE5C;IAAM,CAAE,GAAG,IAAI,CAACL,aAAa;IAErCR,KAAK,CAAC,gBAAgB,EAAEuD,EAAE,CAAC;IAE3B,IAAIE,aAAa,KAAK,IAAI,EAAE;MAC1B,MAAM,IAAI7D,QAAA,CAAA8D,gBAAgB,CAAC,+BAA+B,CAAC;IAC7D;IAEA,MAAMC,KAAK,GAAG,MAAM,IAAI,CAACP,cAAc,CAACI,MAAM,CAAC;IAC/C,MAAMI,SAAS,GAAGZ,MAAM,CAACa,MAAM,CAAC,EAAE,EAAE,IAAApE,MAAA,CAAAsC,OAAI,EAACyB,MAAM,EAAE,UAAU,CAAC,EAAE;MAAEG;IAAK,CAAE,CAAC;IACxE,MAAMG,MAAM,GAAG,MAAML,aAAa,CAACrB,GAAG,CAACmB,EAAE,EAAEK,SAAS,CAAC;IAErD,IAAI,CAACJ,MAAM,CAACO,QAAQ,EAAE;MACpB,OAAOD,MAAM;IACf;IAEA,OAAOL,aAAa,CAACrB,GAAG,CAACmB,EAAE,EAAE;MAAE,GAAGC,MAAM;MAAE,CAAC3C,MAAM,GAAGiD;IAAM,CAAE,CAAC;EAC/D;EAEA,MAAME,WAAWA,CAAC5C,UAAgC,EAAEiC,OAAe;IACjE,OAAOjC,UAAU,CAACV,cAAc,CAACe,OAAO,CAACwC,GAAG;EAC9C;EAEA,MAAMC,YAAYA,CAACxD,cAAqC,EAAE8C,MAA4B;IACpF,MAAM;MAAElC;IAAW,CAAE,GAAGZ,cAAc;IACtC,MAAM;MAAEG;IAAM,CAAE,GAAG,IAAI,CAACL,aAAa;IAErC,IAAI,CAACc,WAAW,EAAE;MAChB,MAAM,IAAI1B,QAAA,CAAA8D,gBAAgB,CAAC,iBAAiB,CAAC;IAC/C;IAEA,MAAMjC,OAAO,GAAG,MAAM,IAAI,CAACf,cAAc,CAACgB,iBAAiB,CAACJ,WAAW,EAAEkC,MAAM,CAACW,GAAG,CAAC;IACpF,MAAML,MAAM,GAAG;MACbxC,WAAW;MACXZ,cAAc,EAAE;QACd4B,QAAQ,EAAE,KAAK;QACfhB,WAAW;QACXG;;KAEH;IAED,IAAIZ,MAAM,KAAK,IAAI,EAAE;MACnB,OAAOiD,MAAM;IACf;IAEA,MAAMhD,QAAQ,GAAG,MAAM,IAAI,CAACkD,WAAW,CAACF,MAAM,EAAEN,MAAM,CAAC;IACvD,MAAMY,KAAK,GAAG,MAAM,IAAI,CAACd,SAAS,CAACxC,QAAQ,EAAE0C,MAAM,CAAC;IAEpD,OAAO;MACL,GAAGM,MAAM;MACT,CAACjD,MAAM,GAAGuD;KACX;EACH;EAEA,MAAMC,KAAKA,CAACC,GAAoB;IAI9B,MAAM;MAAEvD,MAAM;MAAEC;IAAO,CAAE,GAA0C,IAAI,CAACR,aAAa;IACrF,MAAM+D,WAAW,GAAGD,GAAG,CAACE,OAAO,IAAIF,GAAG,CAACE,OAAO,CAACzD,MAAM,CAAC0D,WAAW,EAAE,CAAC;IAEpE,IAAI,CAACF,WAAW,IAAI,OAAOA,WAAW,KAAK,QAAQ,EAAE;MACnD,OAAO,IAAI;IACb;IAEAvE,KAAK,CAAC,2BAA2B,CAAC;IAElC,MAAM,GAAG0E,MAAM,EAAEC,WAAW,CAAC,GAAGJ,WAAW,CAACK,KAAK,CAAC1E,YAAY,CAAC,IAAI,EAAE;IACrE,MAAM2E,SAAS,GAAGH,MAAM,IAAI1D,OAAO,CAAC8D,IAAI,CAAEC,OAAO,IAAK,IAAIC,MAAM,CAACD,OAAO,EAAE,GAAG,CAAC,CAACE,IAAI,CAACP,MAAM,CAAC,CAAC;IAE5F,IAAIA,MAAM,IAAI,CAACG,SAAS,EAAE;MACxB,OAAO,IAAI;IACb;IAEA,OAAO;MACLvC,QAAQ,EAAE,IAAI,CAACC,IAAI;MACnBjB,WAAW,EAAEuD,SAAS,GAAGF,WAAW,GAAGJ;KACxC;EACH;;AA3KFW,OAAA,CAAA/E,WAAA,GAAAA,WAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}