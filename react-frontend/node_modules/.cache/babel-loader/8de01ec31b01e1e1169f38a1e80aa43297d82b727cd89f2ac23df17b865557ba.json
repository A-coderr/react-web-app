{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hookMixin = exports.FeathersHookManager = exports.createContext = exports.enableHooks = exports.collectHooks = exports.convertHookData = void 0;\nconst hooks_1 = require(\"@feathersjs/hooks\");\nconst service_1 = require(\"./service\");\nconst types = ['before', 'after', 'error', 'around'];\nconst isType = value => types.includes(value);\n// Converts different hook registration formats into the\n// same internal format\nfunction convertHookData(input) {\n  const result = {};\n  if (Array.isArray(input)) {\n    result.all = input;\n  } else if (typeof input !== 'object') {\n    result.all = [input];\n  } else {\n    for (const key of Object.keys(input)) {\n      const value = input[key];\n      result[key] = Array.isArray(value) ? value : [value];\n    }\n  }\n  return result;\n}\nexports.convertHookData = convertHookData;\nfunction collectHooks(target, method) {\n  const {\n    collected,\n    collectedAll,\n    around\n  } = target.__hooks;\n  return [...(around.all || []), ...(around[method] || []), ...(collectedAll.before || []), ...(collected[method] || []), ...(collectedAll.after || [])];\n}\nexports.collectHooks = collectHooks;\n// Add `.hooks` functionality to an object\nfunction enableHooks(object) {\n  const store = {\n    around: {},\n    before: {},\n    after: {},\n    error: {},\n    collected: {},\n    collectedAll: {}\n  };\n  Object.defineProperty(object, '__hooks', {\n    configurable: true,\n    value: store,\n    writable: true\n  });\n  return function registerHooks(input) {\n    const store = this.__hooks;\n    const map = Object.keys(input).reduce((map, type) => {\n      if (!isType(type)) {\n        throw new Error(`'${type}' is not a valid hook type`);\n      }\n      map[type] = convertHookData(input[type]);\n      return map;\n    }, {});\n    const types = Object.keys(map);\n    types.forEach(type => Object.keys(map[type]).forEach(method => {\n      var _a;\n      const mapHooks = map[type][method];\n      const storeHooks = (_a = store[type])[method] || (_a[method] = []);\n      storeHooks.push(...mapHooks);\n      if (method === 'all') {\n        if (store.before[method] || store.error[method]) {\n          const beforeAll = (0, hooks_1.collect)({\n            before: store.before[method] || [],\n            error: store.error[method] || []\n          });\n          store.collectedAll.before = [beforeAll];\n        }\n        if (store.after[method]) {\n          const afterAll = (0, hooks_1.collect)({\n            after: store.after[method] || []\n          });\n          store.collectedAll.after = [afterAll];\n        }\n      } else {\n        if (store.before[method] || store.after[method] || store.error[method]) {\n          const collected = (0, hooks_1.collect)({\n            before: store.before[method] || [],\n            after: store.after[method] || [],\n            error: store.error[method] || []\n          });\n          store.collected[method] = [collected];\n        }\n      }\n    }));\n    return this;\n  };\n}\nexports.enableHooks = enableHooks;\nfunction createContext(service, method, data = {}) {\n  const createContext = service[method].createContext;\n  if (typeof createContext !== 'function') {\n    throw new Error(`Can not create context for method ${method}`);\n  }\n  return createContext(data);\n}\nexports.createContext = createContext;\nclass FeathersHookManager extends hooks_1.HookManager {\n  constructor(app, method) {\n    super();\n    this.app = app;\n    this.method = method;\n    this._middleware = [];\n  }\n  collectMiddleware(self, args) {\n    const appHooks = collectHooks(this.app, this.method);\n    const middleware = super.collectMiddleware(self, args);\n    const methodHooks = collectHooks(self, this.method);\n    return [...appHooks, ...middleware, ...methodHooks];\n  }\n  initializeContext(self, args, context) {\n    const ctx = super.initializeContext(self, args, context);\n    ctx.params = ctx.params || {};\n    return ctx;\n  }\n  middleware(mw) {\n    this._middleware.push(...mw);\n    return this;\n  }\n}\nexports.FeathersHookManager = FeathersHookManager;\nfunction hookMixin(service, path, options) {\n  if (typeof service.hooks === 'function') {\n    return service;\n  }\n  const hookMethods = (0, service_1.getHookMethods)(service, options);\n  const serviceMethodHooks = hookMethods.reduce((res, method) => {\n    const params = service_1.defaultServiceArguments[method] || ['data', 'params'];\n    res[method] = new FeathersHookManager(this, method).params(...params).props({\n      app: this,\n      path,\n      method,\n      service,\n      event: null,\n      type: 'around',\n      get statusCode() {\n        var _a;\n        return (_a = this.http) === null || _a === void 0 ? void 0 : _a.status;\n      },\n      set statusCode(value) {\n        this.http = this.http || {};\n        this.http.status = value;\n      }\n    });\n    return res;\n  }, {});\n  const registerHooks = enableHooks(service);\n  (0, hooks_1.hooks)(service, serviceMethodHooks);\n  service.hooks = function (hookOptions) {\n    if (hookOptions.before || hookOptions.after || hookOptions.error || hookOptions.around) {\n      return registerHooks.call(this, hookOptions);\n    }\n    if (Array.isArray(hookOptions)) {\n      return (0, hooks_1.hooks)(this, hookOptions);\n    }\n    Object.keys(hookOptions).forEach(method => {\n      const manager = (0, hooks_1.getManager)(this[method]);\n      if (!(manager instanceof FeathersHookManager)) {\n        throw new Error(`Method ${method} is not a Feathers hooks enabled service method`);\n      }\n      manager.middleware(hookOptions[method]);\n    });\n    return this;\n  };\n  return service;\n}\nexports.hookMixin = hookMixin;","map":{"version":3,"names":["hooks_1","require","service_1","types","isType","value","includes","convertHookData","input","result","Array","isArray","all","key","Object","keys","exports","collectHooks","target","method","collected","collectedAll","around","__hooks","before","after","enableHooks","object","store","error","defineProperty","configurable","writable","registerHooks","map","reduce","type","Error","forEach","mapHooks","storeHooks","_a","push","beforeAll","collect","afterAll","createContext","service","data","FeathersHookManager","HookManager","constructor","app","_middleware","collectMiddleware","self","args","appHooks","middleware","methodHooks","initializeContext","context","ctx","params","mw","hookMixin","path","options","hooks","hookMethods","getHookMethods","serviceMethodHooks","res","defaultServiceArguments","props","event","statusCode","http","status","hookOptions","call","manager","getManager"],"sources":["C:\\Users\\VARLab ROG 1\\Documents\\workspace\\web\\react-frontend\\node_modules\\@feathersjs\\feathers\\src\\hooks.ts"],"sourcesContent":["import {\n  getManager,\n  HookContextData,\n  HookManager,\n  HookMap as BaseHookMap,\n  hooks,\n  Middleware,\n  collect\n} from '@feathersjs/hooks'\nimport {\n  Service,\n  ServiceOptions,\n  HookContext,\n  FeathersService,\n  HookMap,\n  AroundHookFunction,\n  HookFunction,\n  HookType\n} from './declarations'\nimport { defaultServiceArguments, getHookMethods } from './service'\n\ntype ConvertedMap = { [type in HookType]: ReturnType<typeof convertHookData> }\n\ntype HookStore = {\n  around: { [method: string]: AroundHookFunction[] }\n  before: { [method: string]: HookFunction[] }\n  after: { [method: string]: HookFunction[] }\n  error: { [method: string]: HookFunction[] }\n  collected: { [method: string]: AroundHookFunction[] }\n  collectedAll: { before?: AroundHookFunction[]; after?: AroundHookFunction[] }\n}\n\ntype HookEnabled = { __hooks: HookStore }\n\nconst types: HookType[] = ['before', 'after', 'error', 'around']\n\nconst isType = (value: any): value is HookType => types.includes(value)\n\n// Converts different hook registration formats into the\n// same internal format\nexport function convertHookData(input: any) {\n  const result: { [method: string]: HookFunction[] | AroundHookFunction[] } = {}\n\n  if (Array.isArray(input)) {\n    result.all = input\n  } else if (typeof input !== 'object') {\n    result.all = [input]\n  } else {\n    for (const key of Object.keys(input)) {\n      const value = input[key]\n      result[key] = Array.isArray(value) ? value : [value]\n    }\n  }\n\n  return result\n}\n\nexport function collectHooks(target: HookEnabled, method: string) {\n  const { collected, collectedAll, around } = target.__hooks\n\n  return [\n    ...(around.all || []),\n    ...(around[method] || []),\n    ...(collectedAll.before || []),\n    ...(collected[method] || []),\n    ...(collectedAll.after || [])\n  ] as AroundHookFunction[]\n}\n\n// Add `.hooks` functionality to an object\nexport function enableHooks(object: any) {\n  const store: HookStore = {\n    around: {},\n    before: {},\n    after: {},\n    error: {},\n    collected: {},\n    collectedAll: {}\n  }\n\n  Object.defineProperty(object, '__hooks', {\n    configurable: true,\n    value: store,\n    writable: true\n  })\n\n  return function registerHooks(this: HookEnabled, input: HookMap<any, any>) {\n    const store = this.__hooks\n    const map = Object.keys(input).reduce((map, type) => {\n      if (!isType(type)) {\n        throw new Error(`'${type}' is not a valid hook type`)\n      }\n\n      map[type] = convertHookData(input[type])\n\n      return map\n    }, {} as ConvertedMap)\n    const types = Object.keys(map) as HookType[]\n\n    types.forEach((type) =>\n      Object.keys(map[type]).forEach((method) => {\n        const mapHooks = map[type][method]\n        const storeHooks: any[] = (store[type][method] ||= [])\n\n        storeHooks.push(...mapHooks)\n\n        if (method === 'all') {\n          if (store.before[method] || store.error[method]) {\n            const beforeAll = collect({\n              before: store.before[method] || [],\n              error: store.error[method] || []\n            })\n            store.collectedAll.before = [beforeAll]\n          }\n\n          if (store.after[method]) {\n            const afterAll = collect({\n              after: store.after[method] || []\n            })\n            store.collectedAll.after = [afterAll]\n          }\n        } else {\n          if (store.before[method] || store.after[method] || store.error[method]) {\n            const collected = collect({\n              before: store.before[method] || [],\n              after: store.after[method] || [],\n              error: store.error[method] || []\n            })\n\n            store.collected[method] = [collected]\n          }\n        }\n      })\n    )\n\n    return this\n  }\n}\n\nexport function createContext(service: Service, method: string, data: HookContextData = {}) {\n  const createContext = (service as any)[method].createContext\n\n  if (typeof createContext !== 'function') {\n    throw new Error(`Can not create context for method ${method}`)\n  }\n\n  return createContext(data) as HookContext\n}\n\nexport class FeathersHookManager<A> extends HookManager {\n  constructor(\n    public app: A,\n    public method: string\n  ) {\n    super()\n    this._middleware = []\n  }\n\n  collectMiddleware(self: any, args: any[]): Middleware[] {\n    const appHooks = collectHooks(this.app as any as HookEnabled, this.method)\n    const middleware = super.collectMiddleware(self, args)\n    const methodHooks = collectHooks(self, this.method)\n\n    return [...appHooks, ...middleware, ...methodHooks]\n  }\n\n  initializeContext(self: any, args: any[], context: HookContext) {\n    const ctx = super.initializeContext(self, args, context)\n\n    ctx.params = ctx.params || {}\n\n    return ctx\n  }\n\n  middleware(mw: Middleware[]) {\n    this._middleware.push(...mw)\n    return this\n  }\n}\n\nexport function hookMixin<A>(this: A, service: FeathersService<A>, path: string, options: ServiceOptions) {\n  if (typeof service.hooks === 'function') {\n    return service\n  }\n\n  const hookMethods = getHookMethods(service, options)\n\n  const serviceMethodHooks = hookMethods.reduce((res, method) => {\n    const params = (defaultServiceArguments as any)[method] || ['data', 'params']\n\n    res[method] = new FeathersHookManager<A>(this, method).params(...params).props({\n      app: this,\n      path,\n      method,\n      service,\n      event: null,\n      type: 'around',\n      get statusCode() {\n        return this.http?.status\n      },\n      set statusCode(value: number) {\n        this.http = this.http || {}\n        this.http.status = value\n      }\n    })\n\n    return res\n  }, {} as BaseHookMap)\n\n  const registerHooks = enableHooks(service)\n\n  hooks(service, serviceMethodHooks)\n\n  service.hooks = function (this: any, hookOptions: any) {\n    if (hookOptions.before || hookOptions.after || hookOptions.error || hookOptions.around) {\n      return registerHooks.call(this, hookOptions)\n    }\n\n    if (Array.isArray(hookOptions)) {\n      return hooks(this, hookOptions)\n    }\n\n    Object.keys(hookOptions).forEach((method) => {\n      const manager = getManager(this[method])\n\n      if (!(manager instanceof FeathersHookManager)) {\n        throw new Error(`Method ${method} is not a Feathers hooks enabled service method`)\n      }\n\n      manager.middleware(hookOptions[method])\n    })\n\n    return this\n  }\n\n  return service\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}