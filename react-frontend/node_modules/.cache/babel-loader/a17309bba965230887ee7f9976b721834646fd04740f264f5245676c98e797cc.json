{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AuthenticationBase = void 0;\nconst merge_1 = __importDefault(require(\"lodash/merge\"));\nconst jsonwebtoken_1 = __importDefault(require(\"jsonwebtoken\"));\nconst uuid_1 = require(\"uuid\");\nconst errors_1 = require(\"@feathersjs/errors\");\nconst commons_1 = require(\"@feathersjs/commons\");\nconst options_1 = require(\"./options\");\nconst debug = (0, commons_1.createDebug)('@feathersjs/authentication/base');\n/**\n * A base class for managing authentication strategies and creating and verifying JWTs\n */\nclass AuthenticationBase {\n  /**\n   * Create a new authentication service.\n   *\n   * @param app The Feathers application instance\n   * @param configKey The configuration key name in `app.get` (default: `authentication`)\n   * @param options Optional initial options\n   */\n  constructor(app, configKey = 'authentication', options = {}) {\n    if (!app || typeof app.use !== 'function') {\n      throw new Error('An application instance has to be passed to the authentication service');\n    }\n    this.app = app;\n    this.strategies = {};\n    this.configKey = configKey;\n    this.isReady = false;\n    app.set('defaultAuthentication', app.get('defaultAuthentication') || configKey);\n    app.set(configKey, (0, merge_1.default)({}, app.get(configKey), options));\n  }\n  /**\n   * Return the current configuration from the application\n   */\n  get configuration() {\n    // Always returns a copy of the authentication configuration\n    return Object.assign({}, options_1.defaultOptions, this.app.get(this.configKey));\n  }\n  /**\n   * A list of all registered strategy names\n   */\n  get strategyNames() {\n    return Object.keys(this.strategies);\n  }\n  /**\n   * Register a new authentication strategy under a given name.\n   *\n   * @param name The name to register the strategy under\n   * @param strategy The authentication strategy instance\n   */\n  register(name, strategy) {\n    var _a;\n    // Call the functions a strategy can implement\n    if (typeof strategy.setName === 'function') {\n      strategy.setName(name);\n    }\n    if (typeof strategy.setApplication === 'function') {\n      strategy.setApplication(this.app);\n    }\n    if (typeof strategy.setAuthentication === 'function') {\n      strategy.setAuthentication(this);\n    }\n    if (typeof strategy.verifyConfiguration === 'function') {\n      strategy.verifyConfiguration();\n    }\n    // Register strategy as name\n    this.strategies[name] = strategy;\n    if (this.isReady) {\n      (_a = strategy.setup) === null || _a === void 0 ? void 0 : _a.call(strategy, this, name);\n    }\n  }\n  /**\n   * Get the registered authentication strategies for a list of names.\n   *\n   * @param names The list or strategy names\n   */\n  getStrategies(...names) {\n    return names.map(name => this.strategies[name]).filter(current => !!current);\n  }\n  /**\n   * Returns a single strategy by name\n   *\n   * @param name The strategy name\n   * @returns The authentication strategy or undefined\n   */\n  getStrategy(name) {\n    return this.strategies[name];\n  }\n  /**\n   * Create a new access token with payload and options.\n   *\n   * @param payload The JWT payload\n   * @param optsOverride The options to extend the defaults (`configuration.jwtOptions`) with\n   * @param secretOverride Use a different secret instead\n   */\n  async createAccessToken(payload, optsOverride, secretOverride) {\n    const {\n      secret,\n      jwtOptions\n    } = this.configuration;\n    // Use configuration by default but allow overriding the secret\n    const jwtSecret = secretOverride || secret;\n    // Default jwt options merged with additional options\n    const options = (0, merge_1.default)({}, jwtOptions, optsOverride);\n    if (!options.jwtid) {\n      // Generate a UUID as JWT ID by default\n      options.jwtid = (0, uuid_1.v4)();\n    }\n    return jsonwebtoken_1.default.sign(payload, jwtSecret, options);\n  }\n  /**\n   * Verifies an access token.\n   *\n   * @param accessToken The token to verify\n   * @param optsOverride The options to extend the defaults (`configuration.jwtOptions`) with\n   * @param secretOverride Use a different secret instead\n   */\n  async verifyAccessToken(accessToken, optsOverride, secretOverride) {\n    const {\n      secret,\n      jwtOptions\n    } = this.configuration;\n    const jwtSecret = secretOverride || secret;\n    const options = (0, merge_1.default)({}, jwtOptions, optsOverride);\n    const {\n      algorithm\n    } = options;\n    // Normalize the `algorithm` setting into the algorithms array\n    if (algorithm && !options.algorithms) {\n      options.algorithms = Array.isArray(algorithm) ? algorithm : [algorithm];\n      delete options.algorithm;\n    }\n    try {\n      const verified = jsonwebtoken_1.default.verify(accessToken, jwtSecret, options);\n      return verified;\n    } catch (error) {\n      throw new errors_1.NotAuthenticated(error.message, error);\n    }\n  }\n  /**\n   * Authenticate a given authentication request against a list of strategies.\n   *\n   * @param authentication The authentication request\n   * @param params Service call parameters\n   * @param allowed A list of allowed strategy names\n   */\n  async authenticate(authentication, params, ...allowed) {\n    const {\n      strategy\n    } = authentication || {};\n    const [authStrategy] = this.getStrategies(strategy);\n    const strategyAllowed = allowed.includes(strategy);\n    debug('Running authenticate for strategy', strategy, allowed);\n    if (!authentication || !authStrategy || !strategyAllowed) {\n      const additionalInfo = !strategy && ' (no `strategy` set)' || !strategyAllowed && ' (strategy not allowed in authStrategies)' || '';\n      // If there are no valid strategies or `authentication` is not an object\n      throw new errors_1.NotAuthenticated('Invalid authentication information' + additionalInfo);\n    }\n    return authStrategy.authenticate(authentication, {\n      ...params,\n      authenticated: true\n    });\n  }\n  async handleConnection(event, connection, authResult) {\n    const strategies = this.getStrategies(...Object.keys(this.strategies)).filter(current => typeof current.handleConnection === 'function');\n    for (const strategy of strategies) {\n      await strategy.handleConnection(event, connection, authResult);\n    }\n  }\n  /**\n   * Parse an HTTP request and response for authentication request information.\n   *\n   * @param req The HTTP request\n   * @param res The HTTP response\n   * @param names A list of strategies to use\n   */\n  async parse(req, res, ...names) {\n    const strategies = this.getStrategies(...names).filter(current => typeof current.parse === 'function');\n    debug('Strategies parsing HTTP header for authentication information', names);\n    for (const authStrategy of strategies) {\n      const value = await authStrategy.parse(req, res);\n      if (value !== null) {\n        return value;\n      }\n    }\n    return null;\n  }\n  async setup() {\n    var _a;\n    this.isReady = true;\n    for (const name of Object.keys(this.strategies)) {\n      const strategy = this.strategies[name];\n      await ((_a = strategy.setup) === null || _a === void 0 ? void 0 : _a.call(strategy, this, name));\n    }\n  }\n}\nexports.AuthenticationBase = AuthenticationBase;","map":{"version":3,"names":["merge_1","__importDefault","require","jsonwebtoken_1","uuid_1","errors_1","commons_1","options_1","debug","createDebug","AuthenticationBase","constructor","app","configKey","options","use","Error","strategies","isReady","set","get","default","configuration","Object","assign","defaultOptions","strategyNames","keys","register","name","strategy","setName","setApplication","setAuthentication","verifyConfiguration","_a","setup","call","getStrategies","names","map","filter","current","getStrategy","createAccessToken","payload","optsOverride","secretOverride","secret","jwtOptions","jwtSecret","jwtid","v4","sign","verifyAccessToken","accessToken","algorithm","algorithms","Array","isArray","verified","verify","error","NotAuthenticated","message","authenticate","authentication","params","allowed","authStrategy","strategyAllowed","includes","additionalInfo","authenticated","handleConnection","event","connection","authResult","parse","req","res","value","exports"],"sources":["C:\\Users\\VARLab ROG 1\\Documents\\workspace\\web\\react-frontend\\node_modules\\@feathersjs\\authentication\\src\\core.ts"],"sourcesContent":["import merge from 'lodash/merge'\nimport jsonwebtoken, { SignOptions, Secret, VerifyOptions, Algorithm } from 'jsonwebtoken'\nimport { v4 as uuidv4 } from 'uuid'\nimport { NotAuthenticated } from '@feathersjs/errors'\nimport { createDebug } from '@feathersjs/commons'\nimport { Application, Params } from '@feathersjs/feathers'\nimport { IncomingMessage, ServerResponse } from 'http'\nimport { AuthenticationConfiguration, defaultOptions } from './options'\n\nconst debug = createDebug('@feathersjs/authentication/base')\n\nexport interface AuthenticationResult {\n  [key: string]: any\n}\n\nexport interface AuthenticationRequest {\n  strategy?: string\n  [key: string]: any\n}\n\nexport interface AuthenticationParams extends Params {\n  payload?: { [key: string]: any }\n  jwtOptions?: SignOptions\n  authStrategies?: string[]\n  secret?: string\n  [key: string]: any\n}\n\nexport type ConnectionEvent = 'login' | 'logout' | 'disconnect'\n\nexport interface AuthenticationStrategy {\n  /**\n   * Implement this method to get access to the AuthenticationService\n   *\n   * @param auth The AuthenticationService\n   */\n  setAuthentication?(auth: AuthenticationBase): void\n  /**\n   * Implement this method to get access to the Feathers application\n   *\n   * @param app The Feathers application instance\n   */\n  setApplication?(app: Application): void\n  /**\n   * Implement this method to get access to the strategy name\n   *\n   * @param name The name of the strategy\n   */\n  setName?(name: string): void\n  /**\n   * Implement this method to verify the current configuration\n   * and throw an error if it is invalid.\n   */\n  verifyConfiguration?(): void\n  /**\n   * Implement this method to setup this strategy\n   * @param auth The AuthenticationService\n   * @param name The name of the strategy\n   */\n  setup?(auth: AuthenticationBase, name: string): Promise<void>\n  /**\n   * Authenticate an authentication request with this strategy.\n   * Should throw an error if the strategy did not succeed.\n   *\n   * @param authentication The authentication request\n   * @param params The service call parameters\n   */\n  authenticate?(\n    authentication: AuthenticationRequest,\n    params: AuthenticationParams\n  ): Promise<AuthenticationResult>\n  /**\n   * Update a real-time connection according to this strategy.\n   *\n   * @param connection The real-time connection\n   * @param context The hook context\n   */\n  handleConnection?(event: ConnectionEvent, connection: any, authResult?: AuthenticationResult): Promise<void>\n  /**\n   * Parse a basic HTTP request and response for authentication request information.\n   *\n   * @param req The HTTP request\n   * @param res The HTTP response\n   */\n  parse?(req: IncomingMessage, res: ServerResponse): Promise<AuthenticationRequest | null>\n}\n\nexport interface JwtVerifyOptions extends VerifyOptions {\n  algorithm?: string | string[]\n}\n\n/**\n * A base class for managing authentication strategies and creating and verifying JWTs\n */\nexport class AuthenticationBase {\n  app: Application\n  strategies: { [key: string]: AuthenticationStrategy }\n  configKey: string\n  isReady: boolean\n\n  /**\n   * Create a new authentication service.\n   *\n   * @param app The Feathers application instance\n   * @param configKey The configuration key name in `app.get` (default: `authentication`)\n   * @param options Optional initial options\n   */\n  constructor(app: Application, configKey = 'authentication', options = {}) {\n    if (!app || typeof app.use !== 'function') {\n      throw new Error('An application instance has to be passed to the authentication service')\n    }\n\n    this.app = app\n    this.strategies = {}\n    this.configKey = configKey\n    this.isReady = false\n\n    app.set('defaultAuthentication', app.get('defaultAuthentication') || configKey)\n    app.set(configKey, merge({}, app.get(configKey), options))\n  }\n\n  /**\n   * Return the current configuration from the application\n   */\n  get configuration(): AuthenticationConfiguration {\n    // Always returns a copy of the authentication configuration\n    return Object.assign({}, defaultOptions, this.app.get(this.configKey))\n  }\n\n  /**\n   * A list of all registered strategy names\n   */\n  get strategyNames() {\n    return Object.keys(this.strategies)\n  }\n\n  /**\n   * Register a new authentication strategy under a given name.\n   *\n   * @param name The name to register the strategy under\n   * @param strategy The authentication strategy instance\n   */\n  register(name: string, strategy: AuthenticationStrategy) {\n    // Call the functions a strategy can implement\n    if (typeof strategy.setName === 'function') {\n      strategy.setName(name)\n    }\n\n    if (typeof strategy.setApplication === 'function') {\n      strategy.setApplication(this.app)\n    }\n\n    if (typeof strategy.setAuthentication === 'function') {\n      strategy.setAuthentication(this)\n    }\n\n    if (typeof strategy.verifyConfiguration === 'function') {\n      strategy.verifyConfiguration()\n    }\n\n    // Register strategy as name\n    this.strategies[name] = strategy\n\n    if (this.isReady) {\n      strategy.setup?.(this, name)\n    }\n  }\n\n  /**\n   * Get the registered authentication strategies for a list of names.\n   *\n   * @param names The list or strategy names\n   */\n  getStrategies(...names: string[]) {\n    return names.map((name) => this.strategies[name]).filter((current) => !!current)\n  }\n\n  /**\n   * Returns a single strategy by name\n   *\n   * @param name The strategy name\n   * @returns The authentication strategy or undefined\n   */\n  getStrategy(name: string) {\n    return this.strategies[name]\n  }\n\n  /**\n   * Create a new access token with payload and options.\n   *\n   * @param payload The JWT payload\n   * @param optsOverride The options to extend the defaults (`configuration.jwtOptions`) with\n   * @param secretOverride Use a different secret instead\n   */\n  async createAccessToken(\n    payload: string | Buffer | object,\n    optsOverride?: SignOptions,\n    secretOverride?: Secret\n  ) {\n    const { secret, jwtOptions } = this.configuration\n    // Use configuration by default but allow overriding the secret\n    const jwtSecret = secretOverride || secret\n    // Default jwt options merged with additional options\n    const options = merge({}, jwtOptions, optsOverride)\n\n    if (!options.jwtid) {\n      // Generate a UUID as JWT ID by default\n      options.jwtid = uuidv4()\n    }\n\n    return jsonwebtoken.sign(payload, jwtSecret, options)\n  }\n\n  /**\n   * Verifies an access token.\n   *\n   * @param accessToken The token to verify\n   * @param optsOverride The options to extend the defaults (`configuration.jwtOptions`) with\n   * @param secretOverride Use a different secret instead\n   */\n  async verifyAccessToken(accessToken: string, optsOverride?: JwtVerifyOptions, secretOverride?: Secret) {\n    const { secret, jwtOptions } = this.configuration\n    const jwtSecret = secretOverride || secret\n    const options = merge({}, jwtOptions, optsOverride)\n    const { algorithm } = options\n\n    // Normalize the `algorithm` setting into the algorithms array\n    if (algorithm && !options.algorithms) {\n      options.algorithms = (Array.isArray(algorithm) ? algorithm : [algorithm]) as Algorithm[]\n      delete options.algorithm\n    }\n\n    try {\n      const verified = jsonwebtoken.verify(accessToken, jwtSecret, options)\n\n      return verified as any\n    } catch (error: any) {\n      throw new NotAuthenticated(error.message, error)\n    }\n  }\n\n  /**\n   * Authenticate a given authentication request against a list of strategies.\n   *\n   * @param authentication The authentication request\n   * @param params Service call parameters\n   * @param allowed A list of allowed strategy names\n   */\n  async authenticate(\n    authentication: AuthenticationRequest,\n    params: AuthenticationParams,\n    ...allowed: string[]\n  ) {\n    const { strategy } = authentication || {}\n    const [authStrategy] = this.getStrategies(strategy)\n    const strategyAllowed = allowed.includes(strategy)\n\n    debug('Running authenticate for strategy', strategy, allowed)\n\n    if (!authentication || !authStrategy || !strategyAllowed) {\n      const additionalInfo =\n        (!strategy && ' (no `strategy` set)') ||\n        (!strategyAllowed && ' (strategy not allowed in authStrategies)') ||\n        ''\n\n      // If there are no valid strategies or `authentication` is not an object\n      throw new NotAuthenticated('Invalid authentication information' + additionalInfo)\n    }\n\n    return authStrategy.authenticate(authentication, {\n      ...params,\n      authenticated: true\n    })\n  }\n\n  async handleConnection(event: ConnectionEvent, connection: any, authResult?: AuthenticationResult) {\n    const strategies = this.getStrategies(...Object.keys(this.strategies)).filter(\n      (current) => typeof current.handleConnection === 'function'\n    )\n\n    for (const strategy of strategies) {\n      await strategy.handleConnection(event, connection, authResult)\n    }\n  }\n\n  /**\n   * Parse an HTTP request and response for authentication request information.\n   *\n   * @param req The HTTP request\n   * @param res The HTTP response\n   * @param names A list of strategies to use\n   */\n  async parse(req: IncomingMessage, res: ServerResponse, ...names: string[]) {\n    const strategies = this.getStrategies(...names).filter((current) => typeof current.parse === 'function')\n\n    debug('Strategies parsing HTTP header for authentication information', names)\n\n    for (const authStrategy of strategies) {\n      const value = await authStrategy.parse(req, res)\n\n      if (value !== null) {\n        return value\n      }\n    }\n\n    return null\n  }\n\n  async setup() {\n    this.isReady = true\n\n    for (const name of Object.keys(this.strategies)) {\n      const strategy = this.strategies[name]\n\n      await strategy.setup?.(this, name)\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}