{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});","map":{"version":3,"names":[],"sources":["C:\\Users\\VARLab ROG 1\\Documents\\workspace\\web\\react-web-app\\react-frontend\\node_modules\\@feathersjs\\feathers\\src\\declarations.ts"],"sourcesContent":["import { EventEmitter } from 'events'\nimport { NextFunction, HookContext as BaseHookContext } from '@feathersjs/hooks'\n\ntype SelfOrArray<S> = S | S[]\ntype OptionalPick<T, K extends PropertyKey> = Pick<T, Extract<keyof T, K>>\ntype Entries<T> = {\n  [K in keyof T]: [K, T[K]]\n}[keyof T][]\ntype GetKeyByValue<Obj, Value> = Extract<Entries<Obj>[number], [PropertyKey, Value]>[0]\n\nexport type { NextFunction }\n\n/**\n * The object returned from `.find` call by standard database adapters\n */\nexport interface Paginated<T> {\n  total: number\n  limit: number\n  skip: number\n  data: T[]\n}\n\n/**\n * Options that can be passed when registering a service via `app.use(name, service, options)`\n */\nexport interface ServiceOptions<MethodTypes = string> {\n  /**\n   * A list of custom events that this service emits to clients\n   */\n  events?: string[] | readonly string[]\n  /**\n   * A list of service methods that should be available __externally__ to clients\n   */\n  methods?: MethodTypes[] | readonly MethodTypes[]\n  /**\n   * Provide a full list of events that this service should emit to clients.\n   * Unlike the `events` option, this will not be merged with the default events.\n   */\n  serviceEvents?: string[] | readonly string[]\n  /**\n   * Initial data to always add as route params to this service.\n   */\n  routeParams?: { [key: string]: any }\n}\n\nexport interface ClientService<\n  Result = any,\n  Data = Partial<Result>,\n  PatchData = Data,\n  FindResult = Paginated<Result>,\n  P = Params\n> {\n  find(params?: P): Promise<FindResult>\n\n  get(id: Id, params?: P): Promise<Result>\n\n  create(data: Data[], params?: P): Promise<Result[]>\n  create(data: Data, params?: P): Promise<Result>\n\n  update(id: Id, data: Data, params?: P): Promise<Result>\n  update(id: NullableId, data: Data, params?: P): Promise<Result | Result[]>\n  update(id: null, data: Data, params?: P): Promise<Result[]>\n\n  patch(id: NullableId, data: PatchData, params?: P): Promise<Result | Result[]>\n  patch(id: Id, data: PatchData, params?: P): Promise<Result>\n  patch(id: null, data: PatchData, params?: P): Promise<Result[]>\n\n  remove(id: NullableId, params?: P): Promise<Result | Result[]>\n  remove(id: Id, params?: P): Promise<Result>\n  remove(id: null, params?: P): Promise<Result[]>\n}\n\nexport interface ServiceMethods<\n  Result = any,\n  Data = Partial<Result>,\n  ServiceParams = Params,\n  PatchData = Partial<Data>\n> {\n  find(params?: ServiceParams & { paginate?: PaginationParams }): Promise<Result | Result[]>\n\n  get(id: Id, params?: ServiceParams): Promise<Result>\n\n  create(data: Data, params?: ServiceParams): Promise<Result>\n\n  update(id: NullableId, data: Data, params?: ServiceParams): Promise<Result | Result[]>\n\n  patch(id: NullableId, data: PatchData, params?: ServiceParams): Promise<Result | Result[]>\n\n  remove(id: NullableId, params?: ServiceParams): Promise<Result | Result[]>\n\n  setup?(app: Application, path: string): Promise<void>\n\n  teardown?(app: Application, path: string): Promise<void>\n}\n\nexport interface ServiceOverloads<\n  Result = any,\n  Data = Partial<Result>,\n  ServiceParams = Params,\n  PatchData = Partial<Data>\n> {\n  create?(data: Data[], params?: ServiceParams): Promise<Result[]>\n\n  update?(id: Id, data: Data, params?: ServiceParams): Promise<Result>\n\n  update?(id: null, data: Data, params?: ServiceParams): Promise<Result[]>\n\n  patch?(id: Id, data: PatchData, params?: ServiceParams): Promise<Result>\n\n  patch?(id: null, data: PatchData, params?: ServiceParams): Promise<Result[]>\n\n  remove?(id: Id, params?: ServiceParams): Promise<Result>\n\n  remove?(id: null, params?: ServiceParams): Promise<Result[]>\n}\n\n/**\n * A complete service interface. The `ServiceInterface` type should be preferred for customs service\n * implementations\n */\nexport type Service<\n  Result = any,\n  Data = Partial<Result>,\n  ServiceParams = Params,\n  PatchData = Partial<Data>\n> = ServiceMethods<Result, Data, ServiceParams> & ServiceOverloads<Result, Data, ServiceParams, PatchData>\n\n/**\n * The `Service` service interface but with none of the methods required.\n */\nexport type ServiceInterface<\n  Result = any,\n  Data = Partial<Result>,\n  ServiceParams = Params,\n  PatchData = Partial<Data>\n> = Partial<ServiceMethods<Result, Data, ServiceParams, PatchData>>\n\nexport interface ServiceAddons<A = Application, S = Service> extends EventEmitter {\n  id?: string\n  hooks(options: HookOptions<A, S>): this\n}\n\nexport interface ServiceHookOverloads<S, P = Params> {\n  find(params: P & { paginate?: PaginationParams }, context: HookContext): Promise<HookContext>\n\n  get(id: Id, params: P, context: HookContext): Promise<HookContext>\n\n  create(\n    data: ServiceGenericData<S> | ServiceGenericData<S>[],\n    params: P,\n    context: HookContext\n  ): Promise<HookContext>\n\n  update(id: NullableId, data: ServiceGenericData<S>, params: P, context: HookContext): Promise<HookContext>\n\n  patch(id: NullableId, data: ServiceGenericData<S>, params: P, context: HookContext): Promise<HookContext>\n\n  remove(id: NullableId, params: P, context: HookContext): Promise<HookContext>\n}\n\nexport type FeathersService<A = FeathersApplication, S = Service> = S &\n  ServiceAddons<A, S> &\n  OptionalPick<ServiceHookOverloads<S>, keyof S>\n\nexport type CustomMethods<T extends { [key: string]: [any, any] }> = {\n  [K in keyof T]: (data: T[K][0], params?: Params) => Promise<T[K][1]>\n}\n\n/**\n * An interface usually use by transport clients that represents a e.g. HTTP or websocket\n * connection that can be configured on the application.\n */\nexport type TransportConnection<Services = any> = {\n  (app: Application<Services>): void\n  Service: any\n  service: <L extends keyof Services & string>(\n    name: L\n  ) => keyof any extends keyof Services ? ServiceInterface : Services[L]\n}\n\n/**\n * A real-time connection object\n */\nexport interface RealTimeConnection {\n  [key: string]: any\n}\n\n/**\n * The interface for a custom service method. Can e.g. be used to type client side services.\n */\nexport type CustomMethod<T = any, R = T, P extends Params = Params> = (data: T, params?: P) => Promise<R>\n\nexport type ServiceMixin<A> = (service: FeathersService<A>, path: string, options: ServiceOptions) => void\n\nexport type ServiceGenericType<S> = S extends ServiceInterface<infer T> ? T : any\nexport type ServiceGenericData<S> = S extends ServiceInterface<infer _T, infer D> ? D : any\nexport type ServiceGenericParams<S> = S extends ServiceInterface<infer _T, infer _D, infer P> ? P : any\n\nexport interface FeathersApplication<Services = any, Settings = any> {\n  /**\n   * The Feathers application version\n   */\n  version: string\n\n  /**\n   * A list of callbacks that run when a new service is registered\n   */\n  mixins: ServiceMixin<Application<Services, Settings>>[]\n\n  /**\n   * The index of all services keyed by their path.\n   *\n   * __Important:__ Services should always be retrieved via `app.service('name')`\n   * not via `app.services`.\n   */\n  services: Services\n\n  /**\n   * The application settings that can be used via\n   * `app.get` and `app.set`\n   */\n  settings: Settings\n\n  /**\n   * A private-ish indicator if `app.setup()` has been called already\n   */\n  _isSetup: boolean\n\n  /**\n   * Retrieve an application setting by name\n   *\n   * @param name The setting name\n   */\n  get<L extends keyof Settings & string>(name: L): Settings[L]\n\n  /**\n   * Set an application setting\n   *\n   * @param name The setting name\n   * @param value The setting value\n   */\n  set<L extends keyof Settings & string>(name: L, value: Settings[L]): this\n\n  /**\n   * Runs a callback configure function with the current application instance.\n   *\n   * @param callback The callback `(app: Application) => {}` to run\n   */\n  configure(callback: (this: this, app: this) => void): this\n\n  /**\n   * Returns a fallback service instance that will be registered\n   * when no service was found. Usually throws a `NotFound` error\n   * but also used to instantiate client side services.\n   *\n   * @param location The path of the service\n   */\n  defaultService(location: string): ServiceInterface\n\n  /**\n   * Register a new service or a sub-app. When passed another\n   * Feathers application, all its services will be re-registered\n   * with the `path` prefix.\n   *\n   * @param path The path for the service to register\n   * @param service The service object to register or another\n   * Feathers application to use a sub-app under the `path` prefix.\n   * @param options The options for this service\n   */\n  use<L extends keyof Services & string>(\n    path: L,\n    service: keyof any extends keyof Services ? ServiceInterface | Application : Services[L],\n    options?: ServiceOptions<keyof any extends keyof Services ? string : keyof Services[L]>\n  ): this\n\n  /**\n   * Unregister an existing service.\n   *\n   * @param path The name of the service to unregister\n   */\n  unuse<L extends keyof Services & string>(\n    path: L\n  ): Promise<FeathersService<this, keyof any extends keyof Services ? Service : Services[L]>>\n\n  /**\n   * Get the Feathers service instance for a path. This will\n   * be the service originally registered with Feathers functionality\n   * like hooks and events added.\n   *\n   * @param path The name of the service.\n   */\n  service<L extends keyof Services & string>(\n    path: L\n  ): FeathersService<this, keyof any extends keyof Services ? Service : Services[L]>\n\n  /**\n   * Set up the application and call all services `.setup` method if available.\n   *\n   * @param server A server instance (optional)\n   */\n  setup(server?: any): Promise<this>\n\n  /**\n   * Tear down the application and call all services `.teardown` method if available.\n   *\n   * @param server A server instance (optional)\n   */\n  teardown(server?: any): Promise<this>\n\n  /**\n   * Register application level hooks.\n   *\n   * @param map The application hook settings.\n   */\n  hooks(map: ApplicationHookOptions<this>): this\n}\n\n// This needs to be an interface instead of a type\n// so that the declaration can be extended by other modules\nexport interface Application<Services = any, Settings = any>\n  extends FeathersApplication<Services, Settings>,\n    EventEmitter {}\n\nexport type Id = number | string\nexport type NullableId = Id | null\n\nexport interface Query {\n  [key: string]: any\n}\n\nexport interface Params<Q = Query> {\n  query?: Q\n  provider?: string\n  route?: { [key: string]: any }\n  headers?: { [key: string]: any }\n}\n\nexport interface PaginationOptions {\n  default?: number\n  max?: number\n}\n\nexport type PaginationParams = false | PaginationOptions\n\nexport interface Http {\n  /**\n   * A writeable, optional property with status code override.\n   */\n  status?: number\n  /**\n   * A writeable, optional property with headers.\n   */\n  headers?: { [key: string]: string | string[] }\n  /**\n   * A writeable, optional property with `Location` header's value.\n   */\n  location?: string\n}\n\nexport type HookType = 'before' | 'after' | 'error' | 'around'\n\ntype Serv<FA> = FA extends Application<infer S> ? S : never\n\nexport interface HookContext<A = Application, S = any> extends BaseHookContext<ServiceGenericType<S>> {\n  /**\n   * A read only property that contains the Feathers application object. This can be used to\n   * retrieve other services (via context.app.service('name')) or configuration values.\n   */\n  readonly app: A\n  /**\n   * A read only property with the name of the service method (one of find, get,\n   * create, update, patch, remove).\n   */\n  readonly method: string\n  /**\n   * A read only property and contains the service name (or path) without leading or\n   * trailing slashes.\n   */\n  path: 0 extends 1 & S ? keyof Serv<A> & string : GetKeyByValue<Serv<A>, S> & string\n  /**\n   * A read only property and contains the service this hook currently runs on.\n   */\n  readonly service: S\n  /**\n   * A read only property with the hook type (one of 'around', 'before', 'after' or 'error').\n   */\n  readonly type: HookType\n  /**\n   * The list of method arguments. Should not be modified, modify the\n   * `params`, `data` and `id` properties instead.\n   */\n  readonly arguments: any[]\n  /**\n   * A writeable property containing the data of a create, update and patch service\n   * method call.\n   */\n  data?: ServiceGenericData<S>\n  /**\n   * A writeable property with the error object that was thrown in a failed method call.\n   * It is only available in error hooks.\n   */\n  error?: any\n  /**\n   * A writeable property and the id for a get, remove, update and patch service\n   * method call. For remove, update and patch context.id can also be null when\n   * modifying multiple entries. In all other cases it will be undefined.\n   */\n  id?: Id\n  /**\n   * A writeable property that contains the service method parameters (including\n   * params.query).\n   */\n  params: ServiceGenericParams<S>\n  /**\n   * A writeable property containing the result of the successful service method call.\n   * It is only available in after hooks.\n   *\n   * `context.result` can also be set in\n   *\n   * - A before hook to skip the actual service method (database) call\n   * - An error hook to swallow the error and return a result instead\n   */\n  result?: ServiceGenericType<S>\n  /**\n   * A writeable, optional property and contains a 'safe' version of the data that\n   * should be sent to any client. If context.dispatch has not been set context.result\n   * will be sent to the client instead.\n   */\n  dispatch?: ServiceGenericType<S>\n  /**\n   * A writeable, optional property that allows to override the standard HTTP status\n   * code that should be returned.\n   *\n   * @deprecated Use `http.status` instead.\n   */\n  statusCode?: number\n  /**\n   * A writeable, optional property with options specific to HTTP transports.\n   */\n  http?: Http\n  /**\n   * The event emitted by this method. Can be set to `null` to skip event emitting.\n   */\n  event: string | null\n}\n\n// Regular hook typings\nexport type HookFunction<A = Application, S = Service> = (\n  this: S,\n  context: HookContext<A, S>\n) => Promise<HookContext<Application, S> | void> | HookContext<Application, S> | void\n\nexport type Hook<A = Application, S = Service> = HookFunction<A, S>\n\ntype HookMethodMap<A, S> = {\n  [L in keyof S]?: SelfOrArray<HookFunction<A, S>>\n} & { all?: SelfOrArray<HookFunction<A, S>> }\n\ntype HookTypeMap<A, S> = SelfOrArray<HookFunction<A, S>> | HookMethodMap<A, S>\n\n// New @feathersjs/hook typings\nexport type AroundHookFunction<A = Application, S = Service> = (\n  context: HookContext<A, S>,\n  next: NextFunction\n) => Promise<void>\n\nexport type AroundHookMap<A, S> = {\n  [L in keyof S]?: AroundHookFunction<A, S>[]\n} & { all?: AroundHookFunction<A, S>[] }\n\nexport type HookMap<A, S> = {\n  around?: AroundHookMap<A, S>\n  before?: HookTypeMap<A, S>\n  after?: HookTypeMap<A, S>\n  error?: HookTypeMap<A, S>\n}\n\nexport type HookOptions<A, S> = AroundHookMap<A, S> | AroundHookFunction<A, S>[] | HookMap<A, S>\n\nexport interface ApplicationHookContext<A = Application> extends BaseHookContext {\n  app: A\n  server: any\n}\n\nexport type ApplicationHookFunction<A> = (\n  context: ApplicationHookContext<A>,\n  next: NextFunction\n) => Promise<void>\n\nexport type ApplicationHookMap<A> = {\n  setup?: ApplicationHookFunction<A>[]\n  teardown?: ApplicationHookFunction<A>[]\n}\n\nexport type ApplicationHookOptions<A> = HookOptions<A, any> | ApplicationHookMap<A>\n"],"mappings":""},"metadata":{},"sourceType":"script","externalDependencies":[]}