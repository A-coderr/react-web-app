{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Feathers = void 0;\nconst version_1 = __importDefault(require(\"./version\"));\nconst events_1 = require(\"events\");\nconst commons_1 = require(\"@feathersjs/commons\");\nconst hooks_1 = require(\"@feathersjs/hooks\");\nconst events_2 = require(\"./events\");\nconst hooks_2 = require(\"./hooks\");\nconst service_1 = require(\"./service\");\nconst hooks_3 = require(\"./hooks\");\nconst debug = (0, commons_1.createDebug)('@feathersjs/feathers');\nclass Feathers extends events_1.EventEmitter {\n  constructor() {\n    super();\n    this.services = {};\n    this.settings = {};\n    this.mixins = [hooks_2.hookMixin, events_2.eventMixin];\n    this.version = version_1.default;\n    this._isSetup = false;\n    this.registerHooks = (0, hooks_3.enableHooks)(this);\n    this.registerHooks({\n      around: [events_2.eventHook]\n    });\n  }\n  get(name) {\n    return this.settings[name];\n  }\n  set(name, value) {\n    this.settings[name] = value;\n    return this;\n  }\n  configure(callback) {\n    callback.call(this, this);\n    return this;\n  }\n  defaultService(location) {\n    throw new Error(`Can not find service '${location}'`);\n  }\n  service(location) {\n    const path = (0, commons_1.stripSlashes)(location) || '/';\n    const current = this.services.hasOwnProperty(path) ? this.services[path] : undefined;\n    if (typeof current === 'undefined') {\n      this.use(path, this.defaultService(path));\n      return this.service(path);\n    }\n    return current;\n  }\n  _setup() {\n    this._isSetup = true;\n    return Object.keys(this.services).reduce((current, path) => current.then(() => {\n      const service = this.service(path);\n      if (typeof service.setup === 'function') {\n        debug(`Setting up service for \\`${path}\\``);\n        return service.setup(this, path);\n      }\n    }), Promise.resolve()).then(() => this);\n  }\n  get setup() {\n    return this._setup;\n  }\n  set setup(value) {\n    this._setup = value[hooks_1.HOOKS] ? value : (0, hooks_1.hooks)(value, (0, hooks_1.middleware)().params('server').props({\n      app: this\n    }));\n  }\n  _teardown() {\n    this._isSetup = false;\n    return Object.keys(this.services).reduce((current, path) => current.then(() => {\n      const service = this.service(path);\n      if (typeof service.teardown === 'function') {\n        debug(`Tearing down service for \\`${path}\\``);\n        return service.teardown(this, path);\n      }\n    }), Promise.resolve()).then(() => this);\n  }\n  get teardown() {\n    return this._teardown;\n  }\n  set teardown(value) {\n    this._teardown = value[hooks_1.HOOKS] ? value : (0, hooks_1.hooks)(value, (0, hooks_1.middleware)().params('server').props({\n      app: this\n    }));\n  }\n  use(path, service, options) {\n    if (typeof path !== 'string') {\n      throw new Error(`'${path}' is not a valid service path.`);\n    }\n    const location = (0, commons_1.stripSlashes)(path) || '/';\n    const subApp = service;\n    const isSubApp = typeof subApp.service === 'function' && subApp.services;\n    if (isSubApp) {\n      Object.keys(subApp.services).forEach(subPath => this.use(`${location}/${subPath}`, subApp.service(subPath)));\n      return this;\n    }\n    const protoService = (0, service_1.wrapService)(location, service, options);\n    const serviceOptions = (0, service_1.getServiceOptions)(protoService);\n    for (const name of service_1.protectedMethods) {\n      if (serviceOptions.methods.includes(name)) {\n        throw new Error(`'${name}' on service '${location}' is not allowed as a custom method name`);\n      }\n    }\n    debug(`Registering new service at \\`${location}\\``);\n    // Add all the mixins\n    this.mixins.forEach(fn => fn.call(this, protoService, location, serviceOptions));\n    this.services[location] = protoService;\n    // If we ran setup already, set this service up explicitly, this will not `await`\n    if (this._isSetup && typeof protoService.setup === 'function') {\n      debug(`Setting up service for \\`${location}\\``);\n      protoService.setup(this, location);\n    }\n    return this;\n  }\n  async unuse(location) {\n    const path = (0, commons_1.stripSlashes)(location) || '/';\n    const service = this.services[path];\n    if (service && typeof service.teardown === 'function') {\n      await service.teardown(this, path);\n    }\n    delete this.services[path];\n    return service;\n  }\n  hooks(hookMap) {\n    const untypedMap = hookMap;\n    if (untypedMap.before || untypedMap.after || untypedMap.error || untypedMap.around) {\n      // regular hooks for all service methods\n      this.registerHooks(untypedMap);\n    } else if (untypedMap.setup || untypedMap.teardown) {\n      // .setup and .teardown application hooks\n      (0, hooks_1.hooks)(this, untypedMap);\n    } else {\n      // Other registration formats are just `around` hooks\n      this.registerHooks({\n        around: untypedMap\n      });\n    }\n    return this;\n  }\n}\nexports.Feathers = Feathers;","map":{"version":3,"names":["version_1","__importDefault","require","events_1","commons_1","hooks_1","events_2","hooks_2","service_1","hooks_3","debug","createDebug","Feathers","EventEmitter","constructor","services","settings","mixins","hookMixin","eventMixin","version","default","_isSetup","registerHooks","enableHooks","around","eventHook","get","name","set","value","configure","callback","call","defaultService","location","Error","service","path","stripSlashes","current","hasOwnProperty","undefined","use","_setup","Object","keys","reduce","then","setup","Promise","resolve","HOOKS","hooks","middleware","params","props","app","_teardown","teardown","options","subApp","isSubApp","forEach","subPath","protoService","wrapService","serviceOptions","getServiceOptions","protectedMethods","methods","includes","fn","unuse","hookMap","untypedMap","before","after","error","exports"],"sources":["C:\\Users\\VARLab ROG 1\\Documents\\workspace\\web\\react-frontend\\node_modules\\@feathersjs\\feathers\\src\\application.ts"],"sourcesContent":["import version from './version'\nimport { EventEmitter } from 'events'\nimport { stripSlashes, createDebug } from '@feathersjs/commons'\nimport { HOOKS, hooks, middleware } from '@feathersjs/hooks'\nimport { eventHook, eventMixin } from './events'\nimport { hookMixin } from './hooks'\nimport { wrapService, getServiceOptions, protectedMethods } from './service'\nimport {\n  FeathersApplication,\n  ServiceMixin,\n  Service,\n  ServiceOptions,\n  ServiceInterface,\n  Application,\n  FeathersService,\n  ApplicationHookOptions\n} from './declarations'\nimport { enableHooks } from './hooks'\n\nconst debug = createDebug('@feathersjs/feathers')\n\nexport class Feathers<Services, Settings>\n  extends EventEmitter\n  implements FeathersApplication<Services, Settings>\n{\n  services: Services = {} as Services\n  settings: Settings = {} as Settings\n  mixins: ServiceMixin<Application<Services, Settings>>[] = [hookMixin, eventMixin]\n  version: string = version\n  _isSetup = false\n\n  protected registerHooks: (this: any, allHooks: any) => any\n\n  constructor() {\n    super()\n    this.registerHooks = enableHooks(this)\n    this.registerHooks({\n      around: [eventHook]\n    })\n  }\n\n  get<L extends keyof Settings & string>(name: L): Settings[L] {\n    return this.settings[name]\n  }\n\n  set<L extends keyof Settings & string>(name: L, value: Settings[L]) {\n    this.settings[name] = value\n    return this\n  }\n\n  configure(callback: (this: this, app: this) => void) {\n    callback.call(this, this)\n\n    return this\n  }\n\n  defaultService(location: string): ServiceInterface {\n    throw new Error(`Can not find service '${location}'`)\n  }\n\n  service<L extends keyof Services & string>(\n    location: L\n  ): FeathersService<this, keyof any extends keyof Services ? Service : Services[L]> {\n    const path = (stripSlashes(location) || '/') as L\n    const current = this.services.hasOwnProperty(path) ? this.services[path] : undefined\n\n    if (typeof current === 'undefined') {\n      this.use(path, this.defaultService(path) as any)\n      return this.service(path)\n    }\n\n    return current as any\n  }\n\n  protected _setup() {\n    this._isSetup = true\n\n    return Object.keys(this.services)\n      .reduce(\n        (current, path) =>\n          current.then(() => {\n            const service: any = this.service(path as any)\n\n            if (typeof service.setup === 'function') {\n              debug(`Setting up service for \\`${path}\\``)\n\n              return service.setup(this, path)\n            }\n          }),\n        Promise.resolve()\n      )\n      .then(() => this)\n  }\n\n  get setup() {\n    return this._setup\n  }\n\n  set setup(value) {\n    this._setup = (value as any)[HOOKS]\n      ? value\n      : hooks(\n          value,\n          middleware().params('server').props({\n            app: this\n          })\n        )\n  }\n\n  protected _teardown() {\n    this._isSetup = false\n\n    return Object.keys(this.services)\n      .reduce(\n        (current, path) =>\n          current.then(() => {\n            const service: any = this.service(path as any)\n\n            if (typeof service.teardown === 'function') {\n              debug(`Tearing down service for \\`${path}\\``)\n\n              return service.teardown(this, path)\n            }\n          }),\n        Promise.resolve()\n      )\n      .then(() => this)\n  }\n\n  get teardown() {\n    return this._teardown\n  }\n\n  set teardown(value) {\n    this._teardown = (value as any)[HOOKS]\n      ? value\n      : hooks(\n          value,\n          middleware().params('server').props({\n            app: this\n          })\n        )\n  }\n\n  use<L extends keyof Services & string>(\n    path: L,\n    service: keyof any extends keyof Services ? ServiceInterface | Application : Services[L],\n    options?: ServiceOptions<keyof any extends keyof Services ? string : keyof Services[L]>\n  ): this {\n    if (typeof path !== 'string') {\n      throw new Error(`'${path}' is not a valid service path.`)\n    }\n\n    const location = (stripSlashes(path) || '/') as L\n    const subApp = service as Application\n    const isSubApp = typeof subApp.service === 'function' && subApp.services\n\n    if (isSubApp) {\n      Object.keys(subApp.services).forEach((subPath) =>\n        this.use(`${location}/${subPath}` as any, subApp.service(subPath) as any)\n      )\n\n      return this\n    }\n\n    const protoService = wrapService(location, service, options as ServiceOptions)\n    const serviceOptions = getServiceOptions(protoService)\n\n    for (const name of protectedMethods) {\n      if (serviceOptions.methods.includes(name)) {\n        throw new Error(`'${name}' on service '${location}' is not allowed as a custom method name`)\n      }\n    }\n\n    debug(`Registering new service at \\`${location}\\``)\n\n    // Add all the mixins\n    this.mixins.forEach((fn) => fn.call(this, protoService, location, serviceOptions))\n\n    this.services[location] = protoService\n\n    // If we ran setup already, set this service up explicitly, this will not `await`\n    if (this._isSetup && typeof protoService.setup === 'function') {\n      debug(`Setting up service for \\`${location}\\``)\n      protoService.setup(this, location)\n    }\n\n    return this\n  }\n\n  async unuse<L extends keyof Services & string>(\n    location: L\n  ): Promise<FeathersService<this, keyof any extends keyof Services ? Service : Services[L]>> {\n    const path = (stripSlashes(location) || '/') as L\n    const service = this.services[path] as Service\n\n    if (service && typeof service.teardown === 'function') {\n      await service.teardown(this as any, path)\n    }\n\n    delete this.services[path]\n\n    return service as any\n  }\n\n  hooks(hookMap: ApplicationHookOptions<this>) {\n    const untypedMap = hookMap as any\n\n    if (untypedMap.before || untypedMap.after || untypedMap.error || untypedMap.around) {\n      // regular hooks for all service methods\n      this.registerHooks(untypedMap)\n    } else if (untypedMap.setup || untypedMap.teardown) {\n      // .setup and .teardown application hooks\n      hooks(this, untypedMap)\n    } else {\n      // Other registration formats are just `around` hooks\n      this.registerHooks({\n        around: untypedMap\n      })\n    }\n\n    return this\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}