{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ObjectIdSchema = exports.querySyntax = exports.queryProperties = exports.queryProperty = exports.getDataValidator = exports.getValidator = void 0;\nconst commons_1 = require(\"@feathersjs/commons\");\n/**\n * Returns a compiled validation function for a schema and AJV validator instance.\n *\n * @param schema The JSON schema definition\n * @param validator The AJV validation instance\n * @returns A compiled validation function\n */\nconst getValidator = (schema, validator) => validator.compile({\n  $async: true,\n  ...schema\n});\nexports.getValidator = getValidator;\n/**\n * Returns compiled validation functions to validate data for the `create`, `update` and `patch`\n * service methods. If not passed explicitly, the `update` validator will be the same as the `create`\n * and `patch` will be the `create` validator with no required fields.\n *\n * @param def Either general JSON schema definition or a mapping of `create`, `update` and `patch`\n * to their respecitve JSON schema\n * @param validator The Ajv instance to use as the validator\n * @returns A map of validator functions\n */\nconst getDataValidator = (def, validator) => {\n  const schema = def.create ? def : {\n    create: def\n  };\n  return {\n    create: (0, exports.getValidator)(schema.create, validator),\n    update: (0, exports.getValidator)(schema.update || {\n      ...schema.create,\n      $id: `${schema.create.$id}Update`\n    }, validator),\n    patch: (0, exports.getValidator)(schema.patch || {\n      ...schema.create,\n      $id: `${schema.create.$id}Patch`,\n      required: []\n    }, validator)\n  };\n};\nexports.getDataValidator = getDataValidator;\n/**\n * Create a Feathers query syntax compatible JSON schema definition for a property definition.\n *\n * @param def The property definition (e.g. `{ type: 'string' }`)\n * @param extensions Additional properties to add to the query property schema\n * @returns A JSON schema definition for the Feathers query syntax for this property.\n */\nconst queryProperty = (def, extensions = {}) => {\n  const definition = commons_1._.omit(def, 'default');\n  return {\n    anyOf: [definition, {\n      type: 'object',\n      additionalProperties: false,\n      properties: {\n        $gt: definition,\n        $gte: definition,\n        $lt: definition,\n        $lte: definition,\n        $ne: definition,\n        $in: definition.type === 'array' ? definition : {\n          type: 'array',\n          items: definition\n        },\n        $nin: definition.type === 'array' ? definition : {\n          type: 'array',\n          items: definition\n        },\n        ...extensions\n      }\n    }]\n  };\n};\nexports.queryProperty = queryProperty;\n/**\n * Creates Feathers a query syntax compatible JSON schema for multiple properties.\n *\n * @param definitions A map of property definitions\n * @param extensions Additional properties to add to the query property schema\n * @returns The JSON schema definition for the Feathers query syntax for multiple properties\n */\nconst queryProperties = (definitions, extensions = {}) => Object.keys(definitions).reduce((res, key) => {\n  const result = res;\n  const definition = definitions[key];\n  result[key] = (0, exports.queryProperty)(definition, extensions[key]);\n  return result;\n}, {});\nexports.queryProperties = queryProperties;\n/**\n * Creates a JSON schema for the complete Feathers query syntax including `$limit`, $skip`\n * and `$sort` and `$select` for the allowed properties.\n *\n * @param definition The property definitions to create the query syntax schema for\n * @param extensions Additional properties to add to the query property schema\n * @returns A JSON schema for the complete query syntax\n */\nconst querySyntax = (definition, extensions = {}) => {\n  const keys = Object.keys(definition);\n  const props = (0, exports.queryProperties)(definition, extensions);\n  const $or = {\n    type: 'array',\n    items: {\n      type: 'object',\n      additionalProperties: false,\n      properties: props\n    }\n  };\n  const $and = {\n    type: 'array',\n    items: {\n      type: 'object',\n      additionalProperties: false,\n      properties: {\n        ...props,\n        $or\n      }\n    }\n  };\n  return {\n    $limit: {\n      type: 'number',\n      minimum: 0\n    },\n    $skip: {\n      type: 'number',\n      minimum: 0\n    },\n    $sort: {\n      type: 'object',\n      properties: keys.reduce((res, key) => {\n        const result = res;\n        result[key] = {\n          type: 'number',\n          enum: [1, -1]\n        };\n        return result;\n      }, {})\n    },\n    $select: {\n      type: 'array',\n      maxItems: keys.length,\n      items: {\n        type: 'string',\n        ...(keys.length > 0 ? {\n          enum: keys\n        } : {})\n      }\n    },\n    $or,\n    $and,\n    ...props\n  };\n};\nexports.querySyntax = querySyntax;\nconst ObjectIdSchema = () => ({\n  anyOf: [{\n    type: 'string',\n    objectid: true\n  }, {\n    type: 'object',\n    properties: {},\n    additionalProperties: false\n  }]\n});\nexports.ObjectIdSchema = ObjectIdSchema;","map":{"version":3,"names":["commons_1","require","getValidator","schema","validator","compile","$async","exports","getDataValidator","def","create","update","$id","patch","required","queryProperty","extensions","definition","_","omit","anyOf","type","additionalProperties","properties","$gt","$gte","$lt","$lte","$ne","$in","items","$nin","queryProperties","definitions","Object","keys","reduce","res","key","result","querySyntax","props","$or","$and","$limit","minimum","$skip","$sort","enum","$select","maxItems","length","ObjectIdSchema","objectid"],"sources":["C:\\Users\\VARLab ROG 1\\Documents\\workspace\\web\\react-frontend\\node_modules\\@feathersjs\\authentication\\node_modules\\@feathersjs\\schema\\src\\json-schema.ts"],"sourcesContent":["import { _ } from '@feathersjs/commons'\nimport { JSONSchema } from 'json-schema-to-ts'\nimport { JSONSchemaDefinition, Ajv, Validator } from './schema'\n\nexport type DataSchemaMap = {\n  create: JSONSchemaDefinition\n  update?: JSONSchemaDefinition\n  patch?: JSONSchemaDefinition\n}\n\nexport type DataValidatorMap = {\n  create: Validator\n  update: Validator\n  patch: Validator\n}\n\n/**\n * Returns a compiled validation function for a schema and AJV validator instance.\n *\n * @param schema The JSON schema definition\n * @param validator The AJV validation instance\n * @returns A compiled validation function\n */\nexport const getValidator = <T = any, R = T>(schema: JSONSchemaDefinition, validator: Ajv): Validator<T, R> =>\n  validator.compile({\n    $async: true,\n    ...(schema as any)\n  }) as any as Validator<T, R>\n\n/**\n * Returns compiled validation functions to validate data for the `create`, `update` and `patch`\n * service methods. If not passed explicitly, the `update` validator will be the same as the `create`\n * and `patch` will be the `create` validator with no required fields.\n *\n * @param def Either general JSON schema definition or a mapping of `create`, `update` and `patch`\n * to their respecitve JSON schema\n * @param validator The Ajv instance to use as the validator\n * @returns A map of validator functions\n */\nexport const getDataValidator = (\n  def: JSONSchemaDefinition | DataSchemaMap,\n  validator: Ajv\n): DataValidatorMap => {\n  const schema = ((def as any).create ? def : { create: def }) as DataSchemaMap\n\n  return {\n    create: getValidator(schema.create, validator),\n    update: getValidator(\n      schema.update || {\n        ...(schema.create as any),\n        $id: `${schema.create.$id}Update`\n      },\n      validator\n    ),\n    patch: getValidator(\n      schema.patch || {\n        ...(schema.create as any),\n        $id: `${schema.create.$id}Patch`,\n        required: []\n      },\n      validator\n    )\n  }\n}\n\nexport type PropertyQuery<D extends JSONSchema, X> = {\n  anyOf: [\n    D,\n    {\n      type: 'object'\n      additionalProperties: false\n      properties: {\n        $gt: D\n        $gte: D\n        $lt: D\n        $lte: D\n        $ne: D\n        $in: {\n          type: 'array'\n          items: D\n        }\n        $nin: {\n          type: 'array'\n          items: D\n        }\n      } & X\n    }\n  ]\n}\n\n/**\n * Create a Feathers query syntax compatible JSON schema definition for a property definition.\n *\n * @param def The property definition (e.g. `{ type: 'string' }`)\n * @param extensions Additional properties to add to the query property schema\n * @returns A JSON schema definition for the Feathers query syntax for this property.\n */\nexport const queryProperty = <T extends JSONSchema, X extends { [key: string]: JSONSchema }>(\n  def: T,\n  extensions: X = {} as X\n) => {\n  const definition = _.omit(def, 'default')\n  return {\n    anyOf: [\n      definition,\n      {\n        type: 'object',\n        additionalProperties: false,\n        properties: {\n          $gt: definition,\n          $gte: definition,\n          $lt: definition,\n          $lte: definition,\n          $ne: definition,\n          $in:\n            definition.type === 'array'\n              ? definition\n              : {\n                  type: 'array',\n                  items: definition\n                },\n          $nin:\n            definition.type === 'array'\n              ? definition\n              : {\n                  type: 'array',\n                  items: definition\n                },\n          ...extensions\n        }\n      }\n    ]\n  } as const\n}\n\n/**\n * Creates Feathers a query syntax compatible JSON schema for multiple properties.\n *\n * @param definitions A map of property definitions\n * @param extensions Additional properties to add to the query property schema\n * @returns The JSON schema definition for the Feathers query syntax for multiple properties\n */\nexport const queryProperties = <\n  T extends { [key: string]: JSONSchema },\n  X extends { [K in keyof T]?: { [key: string]: JSONSchema } }\n>(\n  definitions: T,\n  extensions: X = {} as X\n) =>\n  Object.keys(definitions).reduce(\n    (res, key) => {\n      const result = res as any\n      const definition = definitions[key]\n\n      result[key] = queryProperty(definition as JSONSchemaDefinition, extensions[key as keyof T])\n\n      return result\n    },\n    {} as { [K in keyof T]: PropertyQuery<T[K], X[K]> }\n  )\n\n/**\n * Creates a JSON schema for the complete Feathers query syntax including `$limit`, $skip`\n * and `$sort` and `$select` for the allowed properties.\n *\n * @param definition The property definitions to create the query syntax schema for\n * @param extensions Additional properties to add to the query property schema\n * @returns A JSON schema for the complete query syntax\n */\nexport const querySyntax = <\n  T extends { [key: string]: JSONSchema },\n  X extends { [K in keyof T]?: { [key: string]: JSONSchema } }\n>(\n  definition: T,\n  extensions: X = {} as X\n) => {\n  const keys = Object.keys(definition)\n  const props = queryProperties(definition, extensions)\n  const $or = {\n    type: 'array',\n    items: {\n      type: 'object',\n      additionalProperties: false,\n      properties: props\n    }\n  } as const\n  const $and = {\n    type: 'array',\n    items: {\n      type: 'object',\n      additionalProperties: false,\n      properties: {\n        ...props,\n        $or\n      }\n    }\n  } as const\n\n  return {\n    $limit: {\n      type: 'number',\n      minimum: 0\n    },\n    $skip: {\n      type: 'number',\n      minimum: 0\n    },\n    $sort: {\n      type: 'object',\n      properties: keys.reduce(\n        (res, key) => {\n          const result = res as any\n\n          result[key] = {\n            type: 'number',\n            enum: [1, -1]\n          }\n\n          return result\n        },\n        {} as { [K in keyof T]: { readonly type: 'number'; readonly enum: [1, -1] } }\n      )\n    },\n    $select: {\n      type: 'array',\n      maxItems: keys.length,\n      items: {\n        type: 'string',\n        ...(keys.length > 0 ? { enum: keys as any as (keyof T)[] } : {})\n      }\n    },\n    $or,\n    $and,\n    ...props\n  } as const\n}\n\nexport const ObjectIdSchema = () =>\n  ({\n    anyOf: [\n      { type: 'string', objectid: true },\n      { type: 'object', properties: {}, additionalProperties: false }\n    ]\n  }) as const\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}